{
  "stage": "testgen",
  "project_root": "C:\\Users\\lenovo\\Desktop\\Diagramscene_ultima-main",
  "created_at": "20251223_200620",
  "meta": {
    "project_root": "C:\\Users\\lenovo\\Desktop\\Diagramscene_ultima-main",
    "llm_output": {
      "out_dir": "tests\\generated",
      "files": [
        "tests/generated/tests.pro",
        "test_diagramitem.cpp",
        "test_deletecommand.cpp",
        "test_diagrampath.cpp",
        "test_findreplacedialog.cpp",
        "tests/generated/test_diagramitemgroup.cpp",
        "tests/generated/test_diagrampath.cpp",
        "tests/generated/test_diagramscene.cpp",
        "tests/generated/test_diagramtextitem.cpp",
        "tests/generated/test_arrow.cpp",
        "tests/generated/test_deletecommand.cpp",
        "tests/generated/test_findreplacedialog.cpp",
        "tests/generated/test_mainwindow.cpp",
        "tests/generated/test_geometry_utils.cpp",
        "tests/generated/test_item_selection.cpp",
        "tests/generated/test_z_order.cpp",
        "tests/generated/test_scene_serialization.cpp",
        "tests/generated/test_command_pattern.cpp",
        "tests/generated/test_bounding_boxes.cpp",
        "tests/generated/test_item_transformations.cpp",
        "tests/generated/test_text_operations.cpp",
        "tests/generated/test_path_operations.cpp",
        "tests/generated/test_scene_cleanup.cpp",
        "tests/generated/test_performance.cpp"
      ],
      "patches": [
        {
          "path": "tests/generated/tests.pro",
          "content": "QT += testlib widgets\nTEMPLATE = app\nTARGET = tests\nCONFIG += console\nCONFIG -= app_bundle\nCONFIG += c++17\n\nSOURCES += \\\n    test_diagramitem.cpp \\\n    test_deletecommand.cpp \\\n    test_diagrampath.cpp \\\n    test_findreplacedialog.cpp\n\nHEADERS += \\\n    test_diagramitem.h \\\n    test_deletecommand.h \\\n    test_diagrampath.h \\\n    test_findreplacedialog.h\n\nINCLUDEPATH += ..\n\n# 假设被测源文件位于项目根目录\nSOURCES += \\\n    ../diagramitem.cpp \\\n    ../deletecommand.cpp \\\n    ../diagrampath.cpp \\\n    ../findreplacedialog.cpp \\\n    ../arrow.cpp \\\n    ../diagramtextitem.cpp\n\nHEADERS += \\\n    ../diagramitem.h \\\n    ../deletecommand.h \\\n    ../diagrampath.h \\\n    ../findreplacedialog.h \\\n    ../arrow.h \\\n    ../diagramtextitem.h \\\n    ../diagramscene.h\n\n# 注意：如果 diagramscene.h 依赖于其他未列出的头文件（如 diagramitemgroup.h），\n# 需要在测试工程中手动添加。\n# 本 .pro 文件基于提供的源文件片段生成，可能缺少某些依赖。"
        },
        {
          "path": "test_diagramitem.cpp",
          "content": "#include <QtTest>\n#include <QGraphicsScene>\n#include <QMenu>\n#include <QPainter>\n#include <QGraphicsView>\n#include \"../diagramitem.h\"\n\nclass TestDiagramItem : public QObject\n{\n    Q_OBJECT\n\nprivate slots:\n    void initTestCase();\n    void cleanupTestCase();\n    void testConstructor();\n    void testBoundingRect();\n    void testSetBrush();\n    void testSetFixedSize();\n    void testRotationAngle();\n    void testTextItemAssociation();\n\nprivate:\n    QGraphicsScene *scene;\n    QMenu *dummyMenu;\n};\n\nvoid TestDiagramItem::initTestCase()\n{\n    scene = new QGraphicsScene;\n    dummyMenu = new QMenu;\n}\n\nvoid TestDiagramItem::cleanupTestCase()\n{\n    delete scene;\n    delete dummyMenu;\n}\n\nvoid TestDiagramItem::testConstructor()\n{\n    DiagramItem item(DiagramItem::Step, dummyMenu);\n    QVERIFY(item.boundingRect().isValid());\n    QCOMPARE(item.diagramType(), DiagramItem::Step);\n    QVERIFY(item.flags() & QGraphicsItem::ItemIsSelectable);\n    QVERIFY(item.flags() & QGraphicsItem::ItemIsMovable);\n}\n\nvoid TestDiagramItem::testBoundingRect()\n{\n    DiagramItem item(DiagramItem::Step, dummyMenu);\n    QRectF rect = item.boundingRect();\n    QVERIFY(rect.width() > 0);\n    QVERIFY(rect.height() > 0);\n    // 初始大小应为 m_grapSize (150,100) 加上边框扩展\n    QVERIFY(rect.width() >= 150);\n    QVERIFY(rect.height() >= 100);\n}\n\nvoid TestDiagramItem::testSetBrush()\n{\n    DiagramItem item(DiagramItem::Step, dummyMenu);\n    QColor newColor(Qt::red);\n    item.setBrush(newColor);\n    // 无法直接验证内部颜色，但调用应不崩溃\n    QVERIFY(true);\n}\n\nvoid TestDiagramItem::testSetFixedSize()\n{\n    DiagramItem item(DiagramItem::Step, dummyMenu);\n    QSizeF newSize(200, 150);\n    item.setFixedSize(newSize);\n    QRectF rect = item.boundingRect();\n    // 检查大小是否近似（考虑旋转和边框）\n    QVERIFY(rect.width() >= 200);\n    QVERIFY(rect.height() >= 150);\n}\n\nvoid TestDiagramItem::testRotationAngle()\n{\n    DiagramItem item(DiagramItem::Step, dummyMenu);\n    QCOMPARE(item.rotationAngle(), 0.0);\n    item.setRotationAngle(45.0);\n    QCOMPARE(item.rotationAngle(), 45.0);\n    // 旋转后边界矩形应仍然有效\n    QVERIFY(item.boundingRect().isValid());\n}\n\nvoid TestDiagramItem::testTextItemAssociation()\n{\n    DiagramItem item(DiagramItem::Step, dummyMenu);\n    // 构造函数应已创建内部的 DiagramTextItem\n    // 无法直接访问，但可验证图元存在\n    QVERIFY(item.childItems().size() > 0);\n}\n\nQTEST_MAIN(TestDiagramItem)\n#include \"test_diagramitem.moc\""
        },
        {
          "path": "test_deletecommand.cpp",
          "content": "#include <QtTest>\n#include <QGraphicsScene>\n#include <QGraphicsRectItem>\n#include \"../deletecommand.h\"\n\nclass TestDeleteCommand : public QObject\n{\n    Q_OBJECT\n\nprivate slots:\n    void initTestCase();\n    void cleanupTestCase();\n    void testConstructor();\n    void testUndoRedo();\n\nprivate:\n    QGraphicsScene *scene;\n    QGraphicsItem *testItem;\n};\n\nvoid TestDeleteCommand::initTestCase()\n{\n    scene = new QGraphicsScene;\n    testItem = new QGraphicsRectItem(0, 0, 100, 100);\n    scene->addItem(testItem);\n}\n\nvoid TestDeleteCommand::cleanupTestCase()\n{\n    delete scene; // 会删除 testItem\n}\n\nvoid TestDeleteCommand::testConstructor()\n{\n    DeleteCommand cmd(testItem, scene);\n    QCOMPARE(cmd.m_item, testItem);\n    QCOMPARE(cmd.m_scene, scene);\n    QCOMPARE(cmd.m_itemPos, testItem->pos());\n    QVERIFY(cmd.m_itemSize.isValid());\n}\n\nvoid TestDeleteCommand::testUndoRedo()\n{\n    // 初始状态：item 在场景中\n    QVERIFY(scene->items().contains(testItem));\n    \n    DeleteCommand cmd(testItem, scene);\n    \n    // 执行 redo：移除 item\n    cmd.redo();\n    QVERIFY(!scene->items().contains(testItem));\n    \n    // 执行 undo：恢复 item\n    cmd.undo();\n    QVERIFY(scene->items().contains(testItem));\n    QCOMPARE(testItem->pos(), cmd.m_itemPos);\n}\n\nQTEST_MAIN(TestDeleteCommand)\n#include \"test_deletecommand.moc\""
        },
        {
          "path": "test_diagrampath.cpp",
          "content": "#include <QtTest>\n#include <QGraphicsScene>\n#include <QMenu>\n#include \"../diagramitem.h\"\n#include \"../diagrampath.h\"\n\nclass TestDiagramPath : public QObject\n{\n    Q_OBJECT\n\nprivate slots:\n    void initTestCase();\n    void cleanupTestCase();\n    void testConstructor();\n    void testQuadFunction();\n    void testUpdatePath();\n    void testGetStartEndItems();\n\nprivate:\n    QGraphicsScene *scene;\n    QMenu *dummyMenu;\n    DiagramItem *startItem;\n    DiagramItem *endItem;\n};\n\nvoid TestDiagramPath::initTestCase()\n{\n    scene = new QGraphicsScene;\n    dummyMenu = new QMenu;\n    startItem = new DiagramItem(DiagramItem::Step, dummyMenu);\n    endItem = new DiagramItem(DiagramItem::Step, dummyMenu);\n    scene->addItem(startItem);\n    scene->addItem(endItem);\n    startItem->setPos(0, 0);\n    endItem->setPos(200, 200);\n}\n\nvoid TestDiagramPath::cleanupTestCase()\n{\n    delete scene; // 会删除 items\n    delete dummyMenu;\n}\n\nvoid TestDiagramPath::testConstructor()\n{\n    DiagramPath path(startItem, endItem, DiagramItem::TF_Right, DiagramItem::TF_Left);\n    QVERIFY(path.path().elementCount() > 0);\n    QCOMPARE(path.getStartItem(), startItem);\n    QCOMPARE(path.getEndItem(), endItem);\n    QVERIFY(path.flags() & QGraphicsItem::ItemIsSelectable);\n}\n\nvoid TestDiagramPath::testQuadFunction()\n{\n    // 测试 quad 辅助函数（假设它是 public 或我们通过友元测试）\n    // 由于 quad 是 private，我们通过路径状态间接测试\n    DiagramPath path(startItem, endItem, DiagramItem::TF_Right, DiagramItem::TF_Left);\n    path.updatePath();\n    // 如果 updatePath 不崩溃，quad 可能工作正常\n    QVERIFY(true);\n}\n\nvoid TestDiagramPath::testUpdatePath()\n{\n    DiagramPath path(startItem, endItem, DiagramItem::TF_Right, DiagramItem::TF_Left);\n    QPainterPath originalPath = path.path();\n    \n    // 移动 endItem 并更新路径\n    endItem->setPos(300, 100);\n    path.updatePath();\n    \n    QPainterPath newPath = path.path();\n    QVERIFY(originalPath != newPath); // 路径应已改变\n    QVERIFY(newPath.elementCount() > 0);\n}\n\nvoid TestDiagramPath::testGetStartEndItems()\n{\n    DiagramPath path(startItem, endItem, DiagramItem::TF_Top, DiagramItem::TF_Bottom);\n    QCOMPARE(path.getStartItem(), startItem);\n    QCOMPARE(path.getEndItem(), endItem);\n}\n\nQTEST_MAIN(TestDiagramPath)\n#include \"test_diagrampath.moc\""
        },
        {
          "path": "test_findreplacedialog.cpp",
          "content": "#include <QtTest>\n#include <QLineEdit>\n#include <QPushButton>\n#include <QVBoxLayout>\n#include \"../findreplacedialog.h\"\n\nclass TestFindReplaceDialog : public QObject\n{\n    Q_OBJECT\n\nprivate slots:\n    void initTestCase();\n    void cleanupTestCase();\n    void testConstructor();\n    void testFindButton();\n    void testReplaceButton();\n    void testReplaceAllButton();\n    void testLineEditContents();\n\nprivate:\n    FindReplaceDialog *dialog;\n};\n\nvoid TestFindReplaceDialog::initTestCase()\n{\n    dialog = new FindReplaceDialog;\n}\n\nvoid TestFindReplaceDialog::cleanupTestCase()\n{\n    delete dialog;\n}\n\nvoid TestFindReplaceDialog::testConstructor()\n{\n    QVERIFY(dialog != nullptr);\n    QVERIFY(dialog->findChild<QLineEdit*>(QString()) != nullptr); // 至少有一个 QLineEdit\n    QVERIFY(dialog->findChild<QPushButton*>(QString()) != nullptr); // 至少有一个 QPushButton\n    QVERIFY(dialog->layout() != nullptr);\n}\n\nvoid TestFindReplaceDialog::testFindButton()\n{\n    QPushButton *findButton = dialog->findChild<QPushButton*>(QString(), Qt::FindDirectChildrenOnly);\n    QVERIFY(findButton != nullptr);\n    QCOMPARE(findButton->text(), QString(\"查找下一个\"));\n    \n    // 测试信号发射（使用 QSignalSpy）\n    QLineEdit *findEdit = dialog->findChild<QLineEdit*>(QString(), Qt::FindDirectChildrenOnly);\n    QVERIFY(findEdit != nullptr);\n    findEdit->setText(\"test\");\n    \n    QSignalSpy spy(dialog, &FindReplaceDialog::findText);\n    QVERIFY(spy.isValid());\n    \n    QTest::mouseClick(findButton, Qt::LeftButton);\n    QCOMPARE(spy.count(), 1);\n    QCOMPARE(spy.at(0).at(0).toString(), QString(\"test\"));\n}\n\nvoid TestFindReplaceDialog::testReplaceButton()\n{\n    QList<QPushButton*> buttons = dialog->findChildren<QPushButton*>();\n    QPushButton *replaceButton = nullptr;\n    for (QPushButton *btn : buttons) {\n        if (btn->text() == \"替换\") {\n            replaceButton = btn;\n            break;\n        }\n    }\n    QVERIFY(replaceButton != nullptr);\n    \n    QLineEdit *findEdit = nullptr;\n    QLineEdit *replaceEdit = nullptr;\n    QList<QLineEdit*> lineEdits = dialog->findChildren<QLineEdit*>();\n    for (QLineEdit *edit : lineEdits) {\n        if (edit->parent() == dialog) {\n            if (!findEdit) findEdit = edit;\n            else if (!replaceEdit) replaceEdit = edit;\n        }\n    }\n    QVERIFY(findEdit && replaceEdit);\n    \n    findEdit->setText(\"old\");\n    replaceEdit->setText(\"new\");\n    \n    QSignalSpy spy(dialog, &FindReplaceDialog::replaceText);\n    QVERIFY(spy.isValid());\n    \n    QTest::mouseClick(replaceButton, Qt::LeftButton);\n    QCOMPARE(spy.count(), 1);\n    QCOMPARE(spy.at(0).at(0).toString(), QString(\"old\"));\n    QCOMPARE(spy.at(0).at(1).toString(), QString(\"new\"));\n}\n\nvoid TestFindReplaceDialog::testReplaceAllButton()\n{\n    QList<QPushButton*> buttons = dialog->findChildren<QPushButton*>();\n    QPushButton *replaceAllButton = nullptr;\n    for (QPushButton *btn : buttons) {\n        if (btn->text() == \"全部替换\") {\n            replaceAllButton = btn;\n            break;\n        }\n    }\n    QVERIFY(replaceAllButton != nullptr);\n    \n    QSignalSpy spy(dialog, &FindReplaceDialog::replaceAllText);\n    QVERIFY(spy.isValid());\n    \n    QTest::mouseClick(replaceAllButton, Qt::LeftButton);\n    QCOMPARE(spy.count(), 1);\n}\n\nvoid TestFindReplaceDialog::testLineEditContents()\n{\n    QList<QLineEdit*> lineEdits = dialog->findChildren<QLineEdit*>();\n    QCOMPARE(lineEdits.size(), 2); // 查找和替换两个输入框\n    \n    // 可以设置和获取文本\n    lineEdits[0]->setText(\"hello\");\n    QCOMPARE(lineEdits[0]->text(), QString(\"hello\"));\n    lineEdits[1]->setText(\"world\");\n    QCOMPARE(lineEdits[1]->text(), QString(\"world\"));\n}\n\nQTEST_MAIN(TestFindReplaceDialog)\n#include \"test_findreplacedialog.moc\""
        },
        {
          "path": "tests/generated/test_diagramitemgroup.cpp",
          "content": "#include <QtTest>\n#include <QMenu>\n#include <QGraphicsScene>\n#include <QGraphicsView>\n#include <QApplication>\n#include \"../diagramitemgroup.h\"\n#include \"../diagramitem.h\"\n\nclass TestDiagramItemGroup : public QObject\n{\n    Q_OBJECT\n\nprivate slots:\n    void initTestCase();\n    void cleanupTestCase();\n    void testConstructor();\n    void testAddItem();\n    void testBoundingRect();\n    void testGetTopLeft();\n    void testPaint();\n    void testHoverMoveEvent();\n    void testMouseMoveEvent();\n\nprivate:\n    QGraphicsScene *scene;\n    DiagramItemGroup *group;\n    DiagramItem *item1;\n    DiagramItem *item2;\n    int argc;\n    char **argv;\n};\n\nvoid TestDiagramItemGroup::initTestCase()\n{\n    // Qt widgets require QApplication\n    static char appName[] = \"test\";\n    static char *argv[] = {appName};\n    int argc = 1;\n    QApplication app(argc, argv);\n\n    scene = new QGraphicsScene();\n    group = new DiagramItemGroup();\n    scene->addItem(group);\n\n    // Create test DiagramItems (using Step type as example)\n    QMenu *dummyMenu = new QMenu();\n    item1 = new DiagramItem(DiagramItem::Step, dummyMenu);\n    item2 = new DiagramItem(DiagramItem::Step, dummyMenu);\n    item1->setPos(50, 50);\n    item2->setPos(150, 150);\n    scene->addItem(item1);\n    scene->addItem(item2);\n}\n\nvoid TestDiagramItemGroup::cleanupTestCase()\n{\n    delete item1;\n    delete item2;\n    delete group;\n    delete scene;\n}\n\nvoid TestDiagramItemGroup::testConstructor()\n{\n    QVERIFY(group != nullptr);\n    QVERIFY(group->flags() & QGraphicsItem::ItemIsSelectable);\n    QVERIFY(group->flags() & QGraphicsItem::ItemIsMovable);\n    QVERIFY(group->acceptHoverEvents());\n}\n\nvoid TestDiagramItemGroup::testAddItem()\n{\n    int initialChildCount = group->childItems().size();\n    group->addItem(item1);\n    QCOMPARE(group->childItems().size(), initialChildCount + 1);\n    QVERIFY(group->childItems().contains(item1));\n    QVERIFY(item1->parentItem() == group);\n}\n\nvoid TestDiagramItemGroup::testBoundingRect()\n{\n    // After adding items, bounding rect should encompass them\n    group->addItem(item1);\n    group->addItem(item2);\n    QRectF rect = group->boundingRect();\n    QVERIFY(rect.width() > 0);\n    QVERIFY(rect.height() > 0);\n    // Top-left should be at (0,0) in local coordinates\n    QCOMPARE(rect.topLeft(), QPointF(0, 0));\n}\n\nvoid TestDiagramItemGroup::testGetTopLeft()\n{\n    // getTopLeft should return the scene coordinates of the group's top-left\n    QPointF topLeft = group->getTopLeft();\n    // Since items were added at (50,50) and (150,150), topLeft should be (50,50)\n    // But note: group's own position may affect this.\n    // For simplicity, we just check it's a valid point\n    QVERIFY(!qIsInf(topLeft.x()) && !qIsInf(topLeft.y()));\n}\n\nvoid TestDiagramItemGroup::testPaint()\n{\n    // Paint is hard to unit test; we just ensure it doesn't crash\n    group->setSelected(true);\n    // Trigger update\n    group->update();\n    // No assertion, just pass if no crash\n    QVERIFY(true);\n}\n\nvoid TestDiagramItemGroup::testHoverMoveEvent()\n{\n    // Simulating hover events is complex; we'll just verify the method exists\n    // by calling a related function or checking state.\n    // For now, we ensure the group is in a valid state.\n    QVERIFY(group->boundingRect().isValid());\n}\n\nvoid TestDiagramItemGroup::testMouseMoveEvent()\n{\n    // Mouse events require a view and actual event loop; we'll skip detailed test.\n    // Instead, verify that the group's transformation state is initialized.\n    // The m_tfState should be TF_Cen (0) initially.\n    // Since m_tfState is private, we cannot directly check.\n    // We'll just ensure the group is movable.\n    QVERIFY(group->flags() & QGraphicsItem::ItemIsMovable);\n}\n\nQTEST_APPLESS_MAIN(TestDiagramItemGroup)\n\n#include \"test_diagramitemgroup.moc\"\n"
        },
        {
          "path": "tests/generated/test_diagrampath.cpp",
          "content": "#include <QtTest>\n#include <QMenu>\n#include <QGraphicsScene>\n#include <QGraphicsView>\n#include \"../diagrampath.h\"\n#include \"../diagramitem.h\"\n\nclass TestDiagramPath : public QObject\n{\n    Q_OBJECT\n\nprivate slots:\n    void initTestCase();\n    void cleanupTestCase();\n    void testConstructor();\n    void testQuadFunction();\n    void testUpdatePath();\n    void testGetStartEndItem();\n    void testDrawZigEdgeCases();\n\nprivate:\n    QGraphicsScene *scene;\n    DiagramItem *startItem;\n    DiagramItem *endItem;\n    DiagramPath *path;\n};\n\nvoid TestDiagramPath::initTestCase()\n{\n    scene = new QGraphicsScene();\n    QMenu *dummyMenu = new QMenu();\n    startItem = new DiagramItem(DiagramItem::Step, dummyMenu);\n    endItem = new DiagramItem(DiagramItem::Step, dummyMenu);\n    scene->addItem(startItem);\n    scene->addItem(endItem);\n    startItem->setPos(0, 0);\n    endItem->setPos(200, 200);\n    path = new DiagramPath(startItem, endItem, DiagramItem::TF_Right, DiagramItem::TF_Left);\n    scene->addItem(path);\n}\n\nvoid TestDiagramPath::cleanupTestCase()\n{\n    delete path;\n    delete endItem;\n    delete startItem;\n    delete scene;\n}\n\nvoid TestDiagramPath::testConstructor()\n{\n    QVERIFY(path != nullptr);\n    QVERIFY(path->getStartItem() == startItem);\n    QVERIFY(path->getEndItem() == endItem);\n    QVERIFY(path->isSelectable());\n}\n\nvoid TestDiagramPath::testQuadFunction()\n{\n    // Quadrant 1: start.x <= end.x && start.y >= end.y\n    QCOMPARE(path->quad(QPointF(0, 100), QPointF(100, 0)), 1);\n    // Quadrant 2: start.x <= end.x && start.y <= end.y\n    QCOMPARE(path->quad(QPointF(0, 0), QPointF(100, 100)), 2);\n    // Quadrant 3: start.x >= end.x && start.y <= end.y\n    QCOMPARE(path->quad(QPointF(100, 0), QPointF(0, 100)), 3);\n    // Quadrant 4: start.x >= end.x && start.y >= end.y\n    QCOMPARE(path->quad(QPointF(100, 100), QPointF(0, 0)), 4);\n}\n\nvoid TestDiagramPath::testUpdatePath()\n{\n    QPainterPath originalPath = path->path();\n    startItem->setPos(50, 50);\n    path->updatePath();\n    QPainterPath updatedPath = path->path();\n    QVERIFY(originalPath != updatedPath);\n    QVERIFY(!updatedPath.isEmpty());\n}\n\nvoid TestDiagramPath::testGetStartEndItem()\n{\n    QCOMPARE(path->getStartItem(), startItem);\n    QCOMPARE(path->getEndItem(), endItem);\n}\n\nvoid TestDiagramPath::testDrawZigEdgeCases()\n{\n    // Test a known state that triggers a zig draw\n    // State 842: startState=8(TF_Right), endState=4(TF_Bottom), quad=2\n    // This should draw a vertical zig\n    DiagramPath *path2 = new DiagramPath(startItem, endItem, DiagramItem::TF_Right, DiagramItem::TF_Bottom);\n    scene->addItem(path2);\n    path2->updatePath();\n    QPainterPath p = path2->path();\n    QVERIFY(!p.isEmpty());\n    delete path2;\n}\n\nQTEST_MAIN(TestDiagramPath)\n#include \"test_diagrampath.moc\""
        },
        {
          "path": "tests/generated/test_diagramscene.cpp",
          "content": "#include <QtTest>\n#include <QMenu>\n#include <QGraphicsScene>\n#include <QGraphicsView>\n#include <QColor>\n#include <QFont>\n#include <QSignalSpy>\n#include <QPainter>\n#include <QImage>\n#include \"../diagramscene.h\"\n#include \"../diagramitem.h\"\n#include \"../diagramtextitem.h\"\n#include \"../arrow.h\"\n#include \"../diagrampath.h\"\n\nclass TestDiagramScene : public QObject\n{\n    Q_OBJECT\n\nprivate:\n    DiagramScene *scene;\n    QMenu *itemMenu;\n\nprivate slots:\n    void initTestCase() {\n        itemMenu = new QMenu();\n        scene = new DiagramScene(itemMenu);\n    }\n    \n    void cleanupTestCase() {\n        delete scene;\n        delete itemMenu;\n    }\n    \n    void testConstructor() {\n        QVERIFY(scene != nullptr);\n        // 假设 DiagramScene 有 mode() 和 itemType() 访问器\n        // 如果没有，这些测试可能需要调整\n        // QCOMPARE(scene->mode(), DiagramScene::MoveItem);\n        // QCOMPARE(scene->itemType(), DiagramItem::Step);\n    }\n    \n    void testSetMode() {\n        // 测试设置模式函数调用不崩溃\n        scene->setMode(DiagramScene::InsertItem);\n        scene->setMode(DiagramScene::InsertText);\n        scene->setMode(DiagramScene::InsertLine);\n        scene->setMode(DiagramScene::MoveItem);\n        QVERIFY(true);\n    }\n    \n    void testSetItemType() {\n        // 测试设置图元类型函数调用不崩溃\n        scene->setItemType(DiagramItem::StartEnd);\n        scene->setItemType(DiagramItem::Conditional);\n        scene->setItemType(DiagramItem::Step);\n        scene->setItemType(DiagramItem::circular);\n        scene->setItemType(DiagramItem::Document);\n        scene->setItemType(DiagramItem::PredefinedProcess);\n        scene->setItemType(DiagramItem::StoredData);\n        QVERIFY(true);\n    }\n    \n    void testSetLineColor() {\n        QColor testColor(255, 0, 0);\n        scene->setLineColor(testColor);\n        QVERIFY(true);\n    }\n    \n    void testSetTextColor() {\n        QColor testColor(0, 255, 0);\n        scene->setTextColor(testColor);\n        QVERIFY(true);\n    }\n    \n    void testSetItemColor() {\n        QColor testColor(0, 0, 255);\n        scene->setItemColor(testColor);\n        QVERIFY(true);\n    }\n    \n    void testSetFont() {\n        QFont testFont(\"Arial\", 12, QFont::Bold);\n        scene->setFont(testFont);\n        QVERIFY(true);\n    }\n    \n    void testItemInsertedSignal() {\n        QSignalSpy spy(scene, &DiagramScene::itemInserted);\n        QVERIFY(spy.isValid());\n    }\n    \n    void testTextInsertedSignal() {\n        QSignalSpy spy(scene, &DiagramScene::textInserted);\n        QVERIFY(spy.isValid());\n    }\n    \n    void testItemSelectedSignal() {\n        QSignalSpy spy(scene, &DiagramScene::itemSelected);\n        QVERIFY(spy.isValid());\n    }\n    \n    void testPathInsertedSignal() {\n        QSignalSpy spy(scene, &DiagramScene::pathInserted);\n        QVERIFY(spy.isValid());\n    }\n    \n    void testSceneItemManagement() {\n        DiagramItem *item = new DiagramItem(DiagramItem::Step, itemMenu);\n        scene->addItem(item);\n        QVERIFY(scene->items().contains(item));\n        scene->removeItem(item);\n        QVERIFY(!scene->items().contains(item));\n        delete item;\n    }\n    \n    void testClearScene() {\n        DiagramItem *item1 = new DiagramItem(DiagramItem::Step, itemMenu);\n        DiagramItem *item2 = new DiagramItem(DiagramItem::Conditional, itemMenu);\n        DiagramTextItem *textItem = new DiagramTextItem();\n        scene->addItem(item1);\n        scene->addItem(item2);\n        scene->addItem(textItem);\n        int initialCount = scene->items().count();\n        QVERIFY(initialCount >= 3);\n        scene->clear();\n        QCOMPARE(scene->items().count(), 0);\n    }\n    \n    void testSelectedItems() {\n        DiagramItem *item1 = new DiagramItem(DiagramItem::Step, itemMenu);\n        DiagramItem *item2 = new DiagramItem(DiagramItem::Conditional, itemMenu);\n        DiagramTextItem *textItem = new DiagramTextItem();\n        scene->addItem(item1);\n        scene->addItem(item2);\n        scene->addItem(textItem);\n        item1->setSelected(true);\n        QList<QGraphicsItem*> selected = scene->selectedItems();\n        QCOMPARE(selected.count(), 1);\n        QCOMPARE(selected.first(), static_cast<QGraphicsItem*>(item1));\n        item2->setSelected(true);\n        textItem->setSelected(true);\n        selected = scene->selectedItems();\n        QCOMPARE(selected.count(), 3);\n        scene->clear();\n    }\n    \n    void testSceneRect() {\n        QRectF testRect(0, 0, 1000, 800);\n        scene->setSceneRect(testRect);\n        QCOMPARE(scene->sceneRect(), testRect);\n    }\n    \n    void testBackgroundBrush() {\n        QBrush testBrush(Qt::lightGray);\n        scene->setBackgroundBrush(testBrush);\n        QCOMPARE(scene->backgroundBrush(), testBrush);\n    }\n    \n    void testForegroundBrush() {\n        QBrush testBrush(Qt::darkGray, Qt::Dense4Pattern);\n        scene->setForegroundBrush(testBrush);\n        QCOMPARE(scene->foregroundBrush(), testBrush);\n    }\n    \n    void testItemAtPosition() {\n        DiagramItem *item = new DiagramItem(DiagramItem::Step, itemMenu);\n        item->setPos(100, 100);\n        scene->addItem(item);\n        QGraphicsItem *foundItem = scene->itemAt(100, 100, QTransform());\n        QVERIFY(foundItem != nullptr);\n        QCOMPARE(foundItem, static_cast<QGraphicsItem*>(item));\n        QGraphicsItem *noItem = scene->itemAt(500, 500, QTransform());\n        QVERIFY(noItem == nullptr);\n        scene->removeItem(item);\n        delete item;\n    }\n    \n    void testItemsInRect() {\n        DiagramItem *item1 = new DiagramItem(DiagramItem::Step, itemMenu);\n        item1->setPos(50, 50);\n        scene->addItem(item1);\n        DiagramItem *item2 = new DiagramItem(DiagramItem::Conditional, itemMenu);\n        item2->setPos(200, 200);\n        scene->addItem(item2);\n        QRectF searchRect(0, 0, 100, 100);\n        QList<QGraphicsItem*> items = scene->items(searchRect, Qt::IntersectsItemShape);\n        QVERIFY(items.contains(item1));\n        QVERIFY(!items.contains(item2));\n        searchRect = QRectF(0, 0, 250, 250);\n        items = scene->items(searchRect, Qt::IntersectsItemShape);\n        QVERIFY(items.contains(item1));\n        QVERIFY(items.contains(item2));\n        scene->clear();\n    }\n    \n    void testCollidingItems() {\n        DiagramItem *item1 = new DiagramItem(DiagramItem::Step, itemMenu);\n        item1->setPos(100, 100);\n        scene->addItem(item1);\n        DiagramItem *item2 = new DiagramItem(DiagramItem::Step, itemMenu);\n        item2->setPos(110, 110);\n        scene->addItem(item2);\n        QList<QGraphicsItem*> colliding = scene->collidingItems(item1);\n        QVERIFY(colliding.contains(item2));\n        scene->clear();\n    }\n    \n    void testFocusItem() {\n        DiagramTextItem *textItem = new DiagramTextItem();\n        scene->addItem(textItem);\n        scene->setFocusItem(textItem);\n        QCOMPARE(scene->focusItem(), static_cast<QGraphicsItem*>(textItem));\n        scene->setFocusItem(nullptr);\n        QVERIFY(scene->focusItem() == nullptr);\n        scene->removeItem(textItem);\n        delete textItem;\n    }\n    \n    void testSelectionArea() {\n        DiagramItem *item1 = new DiagramItem(DiagramItem::Step, itemMenu);\n        item1->setPos(50, 50);\n        scene->addItem(item1);\n        DiagramItem *item2 = new DiagramItem(DiagramItem::Conditional, itemMenu);\n        item2->setPos(150, 150);\n        scene->addItem(item2);\n        QPainterPath selectionPath;\n        selectionPath.addRect(0, 0, 100, 100);\n        scene->setSelectionArea(selectionPath);\n        QVERIFY(item1->isSelected());\n        QVERIFY(!item2->isSelected());\n        scene->clear();\n    }\n    \n    void testRenderToPainter() {\n        DiagramItem *item = new DiagramItem(DiagramItem::Step, itemMenu);\n        item->setPos(100, 100);\n        scene->addItem(item);\n        QImage image(400, 300, QImage::Format_ARGB32);\n        image.fill(Qt::white);\n        QPainter painter(&image);\n        scene->render(&painter);\n        QVERIFY(!image.isNull());\n        scene->clear();\n    }\n    \n    void testSceneUpdate() {\n        DiagramItem *item = new DiagramItem(DiagramItem::Step, itemMenu);\n        scene->addItem(item);\n        QRectF itemRect = item->boundingRect().translated(item->pos());\n        scene->update(itemRect);\n        scene->update();\n        QVERIFY(true);\n        scene->clear();\n    }\n    \n    void testItemIndexMethod() {\n        scene->setItemIndexMethod(QGraphicsScene::NoIndex);\n        QCOMPARE(scene->itemIndexMethod(), QGraphicsScene::NoIndex);\n        scene->setItemIndexMethod(QGraphicsScene::BspTreeIndex);\n        QCOMPARE(scene->itemIndexMethod(), QGraphicsScene::BspTreeIndex);\n    }\n    \n    void testSceneSignals() {\n        QSignalSpy sceneRectSpy(scene, &QGraphicsScene::sceneRectChanged);\n        QSignalSpy selectionSpy(scene, &QGraphicsScene::selectionChanged);\n        scene->setSceneRect(0, 0, 500, 500);\n        QVERIFY(sceneRectSpy.count() > 0);\n        DiagramItem *item = new DiagramItem(DiagramItem::Step, itemMenu);\n        scene->addItem(item);\n        item->setSelected(true);\n        QVERIFY(selectionSpy.count() > 0);\n        scene->clear();\n    }\n    \n    void testItemZValue() {\n        DiagramItem *item1 = new DiagramItem(DiagramItem::Step, itemMenu);\n        DiagramItem *item2 = new DiagramItem(DiagramItem::Conditional, itemMenu);\n        scene->addItem(item1);\n        scene->addItem(item2);\n        item1->setZValue(1.0);\n        item2->setZValue(2.0);\n        QCOMPARE(item1->zValue(), 1.0);\n        QCOMPARE(item2->zValue(), 2.0);\n        QVERIFY(item2->zValue() > item1->zValue());\n        scene->clear();\n    }\n    \n    void testItemParentChild() {\n        DiagramItem *parentItem = new DiagramItem(DiagramItem::Step, itemMenu);\n        DiagramItem *childItem = new DiagramItem(DiagramItem::Conditional, itemMenu);\n        childItem->setParentItem(parentItem);\n        scene->addItem(parentItem);\n        QVERIFY(childItem->parentItem() == parentItem);\n        QVERIFY(parentItem->childItems().contains(childItem));\n        scene->clear();\n    }\n};\n\nQTEST_MAIN(TestDiagramScene)\n#include \"test_diagramscene.moc\""
        },
        {
          "path": "tests/generated/test_diagramtextitem.cpp",
          "content": "#include <QtTest>\n#include <QGraphicsScene>\n#include <QGraphicsView>\n#include <QApplication>\n#include \"../diagramtextitem.h\"\n#include \"../diagramscene.h\"\n\nclass TestDiagramTextItem : public QObject\n{\n    Q_OBJECT\n\nprivate slots:\n    void initTestCase();\n    void cleanupTestCase();\n    void testConstructor();\n    void testItemFlags();\n    void testTextInteraction();\n    void testItemChangeSignal();\n    void testFocusOutEvent();\n    void testMouseDoubleClickEvent();\n    void testSetDefaultTextColor();\n    void testSetFont();\n    void testSetPlainText();\n    void testSetPos();\n    void testBoundingRect();\n    void testParentItem();\n\nprivate:\n    QGraphicsScene *scene;\n    DiagramTextItem *textItem;\n    int signalReceivedCount;\n};\n\nvoid TestDiagramTextItem::initTestCase()\n{\n    int argc = 0;\n    char **argv = nullptr;\n    QApplication app(argc, argv); // QGraphicsItem requires QApplication\n    \n    scene = new QGraphicsScene();\n    textItem = new DiagramTextItem();\n    scene->addItem(textItem);\n    signalReceivedCount = 0;\n}\n\nvoid TestDiagramTextItem::cleanupTestCase()\n{\n    delete scene; // scene will delete textItem\n}\n\nvoid TestDiagramTextItem::testConstructor()\n{\n    DiagramTextItem *item = new DiagramTextItem();\n    QVERIFY(item != nullptr);\n    QVERIFY(item->parentItem() == nullptr);\n    delete item;\n}\n\nvoid TestDiagramTextItem::testItemFlags()\n{\n    QVERIFY(textItem->flags() & QGraphicsItem::ItemIsMovable);\n    QVERIFY(textItem->flags() & QGraphicsItem::ItemIsSelectable);\n}\n\nvoid TestDiagramTextItem::testTextInteraction()\n{\n    QCOMPARE(textItem->textInteractionFlags(), Qt::TextEditorInteraction);\n}\n\nvoid TestDiagramTextItem::testItemChangeSignal()\n{\n    // Connect to the selectedChange signal\n    QObject::connect(textItem, &DiagramTextItem::selectedChange, [this](DiagramTextItem *item) {\n        Q_UNUSED(item);\n        signalReceivedCount++;\n    });\n    \n    int initialCount = signalReceivedCount;\n    textItem->setSelected(true);\n    QVERIFY(signalReceivedCount > initialCount);\n    \n    textItem->setSelected(false);\n    QVERIFY(signalReceivedCount > initialCount + 1);\n}\n\nvoid TestDiagramTextItem::testFocusOutEvent()\n{\n    // Simulate focus out by setting interaction flags to NoTextInteraction\n    textItem->setTextInteractionFlags(Qt::NoTextInteraction);\n    QCOMPARE(textItem->textInteractionFlags(), Qt::NoTextInteraction);\n}\n\nvoid TestDiagramTextItem::testMouseDoubleClickEvent()\n{\n    // After double-click, interaction should be TextEditorInteraction\n    textItem->setTextInteractionFlags(Qt::NoTextInteraction);\n    // Note: We cannot simulate actual mouse events in unit test easily\n    // This is a smoke test to verify the method exists\n    QVERIFY(true);\n}\n\nvoid TestDiagramTextItem::testSetDefaultTextColor()\n{\n    QColor red(Qt::red);\n    textItem->setDefaultTextColor(red);\n    QCOMPARE(textItem->defaultTextColor(), red);\n}\n\nvoid TestDiagramTextItem::testSetFont()\n{\n    QFont font(\"Arial\", 12, QFont::Bold);\n    textItem->setFont(font);\n    QCOMPARE(textItem->font(), font);\n}\n\nvoid TestDiagramTextItem::testSetPlainText()\n{\n    QString testText = \"Test Diagram Text\";\n    textItem->setPlainText(testText);\n    QCOMPARE(textItem->toPlainText(), testText);\n}\n\nvoid TestDiagramTextItem::testSetPos()\n{\n    QPointF pos(100, 150);\n    textItem->setPos(pos);\n    QCOMPARE(textItem->pos(), pos);\n}\n\nvoid TestDiagramTextItem::testBoundingRect()\n{\n    textItem->setPlainText(\"Test\");\n    QRectF rect = textItem->boundingRect();\n    QVERIFY(rect.width() > 0);\n    QVERIFY(rect.height() > 0);\n}\n\nvoid TestDiagramTextItem::testParentItem()\n{\n    DiagramItem *parentItem = new DiagramItem(DiagramItem::Step, nullptr);\n    DiagramTextItem *childTextItem = new DiagramTextItem(parentItem);\n    QVERIFY(childTextItem->parentItem() == parentItem);\n    delete parentItem; // child will be deleted automatically\n}\n\nQTEST_MAIN(TestDiagramTextItem)\n#include \"test_diagramtextitem.moc\""
        },
        {
          "path": "tests/generated/test_arrow.cpp",
          "content": "#include <QtTest>\n#include \"arrow.h\"\n#include \"diagramitem.h\"\n#include <QGraphicsScene>\n#include <QGraphicsView>\n\nclass TestArrow : public QObject\n{\n    Q_OBJECT\n\nprivate slots:\n    void initTestCase();\n    void cleanupTestCase();\n    void testConstructor();\n    void testUpdatePosition();\n    void testBoundingRect();\n    void testShape();\n    void testColor();\n    void testSelection();\n\nprivate:\n    QGraphicsScene *scene;\n    DiagramItem *startItem;\n    DiagramItem *endItem;\n    Arrow *arrow;\n};\n\nvoid TestArrow::initTestCase()\n{\n    scene = new QGraphicsScene();\n    startItem = new DiagramItem(DiagramItem::Step, nullptr);\n    endItem = new DiagramItem(DiagramItem::Step, nullptr);\n    scene->addItem(startItem);\n    scene->addItem(endItem);\n    startItem->setPos(0, 0);\n    endItem->setPos(100, 100);\n    arrow = new Arrow(startItem, endItem);\n    scene->addItem(arrow);\n}\n\nvoid TestArrow::cleanupTestCase()\n{\n    delete scene;\n}\n\nvoid TestArrow::testConstructor()\n{\n    QVERIFY(arrow != nullptr);\n    QCOMPARE(arrow->myStartItem, startItem);\n    QCOMPARE(arrow->myEndItem, endItem);\n    QVERIFY(arrow->flags() & QGraphicsItem::ItemIsSelectable);\n}\n\nvoid TestArrow::testUpdatePosition()\n{\n    QLineF initialLine = arrow->line();\n    startItem->setPos(50, 50);\n    arrow->updatePosition();\n    QLineF updatedLine = arrow->line();\n    QVERIFY(initialLine != updatedLine);\n    QCOMPARE(updatedLine.p1(), startItem->pos());\n    QCOMPARE(updatedLine.p2(), endItem->pos());\n}\n\nvoid TestArrow::testBoundingRect()\n{\n    QRectF bRect = arrow->boundingRect();\n    QVERIFY(bRect.isValid());\n    QVERIFY(bRect.contains(arrow->line().p1()));\n    QVERIFY(bRect.contains(arrow->line().p2()));\n    qreal extra = (arrow->pen().width() + 20) / 2.0;\n    QVERIFY(bRect.width() >= arrow->line().length() + 2 * extra);\n}\n\nvoid TestArrow::testShape()\n{\n    QPainterPath shape = arrow->shape();\n    QVERIFY(!shape.isEmpty());\n    QVERIFY(shape.contains(arrow->line().p1()));\n}\n\nvoid TestArrow::testColor()\n{\n    QColor newColor(Qt::red);\n    arrow->setColor(newColor);\n    QCOMPARE(arrow->myColor, newColor);\n    QCOMPARE(arrow->pen().color(), newColor);\n}\n\nvoid TestArrow::testSelection()\n{\n    arrow->setSelected(true);\n    QVERIFY(arrow->isSelected());\n    arrow->setSelected(false);\n    QVERIFY(!arrow->isSelected());\n}\n\nQTEST_MAIN(TestArrow)\n#include \"test_arrow.moc\""
        },
        {
          "path": "tests/generated/test_deletecommand.cpp",
          "content": "#include <QtTest>\n#include <QUndoStack>\n#include <QGraphicsScene>\n#include <QGraphicsRectItem>\n#include \"../deletecommand.h\"\n\nclass TestDeleteCommand : public QObject\n{\n    Q_OBJECT\n\nprivate slots:\n    void initTestCase();\n    void cleanupTestCase();\n    void testConstructor();\n    void testRedoRemovesItem();\n    void testUndoAddsItemBack();\n    void testCommandText();\n    void testSceneOwnership();\n\nprivate:\n    QGraphicsScene *scene;\n    QGraphicsRectItem *testItem;\n    QUndoStack *undoStack;\n};\n\nvoid TestDeleteCommand::initTestCase()\n{\n    scene = new QGraphicsScene();\n    testItem = new QGraphicsRectItem(0, 0, 100, 50);\n    scene->addItem(testItem);\n    undoStack = new QUndoStack();\n}\n\nvoid TestDeleteCommand::cleanupTestCase()\n{\n    delete undoStack;\n    delete scene;\n    // testItem is owned by scene, will be deleted with scene\n}\n\nvoid TestDeleteCommand::testConstructor()\n{\n    DeleteCommand *cmd = new DeleteCommand(testItem, scene);\n    QVERIFY(cmd != nullptr);\n    QCOMPARE(cmd->scene(), scene);\n    delete cmd;\n}\n\nvoid TestDeleteCommand::testRedoRemovesItem()\n{\n    QVERIFY(scene->items().contains(testItem));\n    \n    DeleteCommand *cmd = new DeleteCommand(testItem, scene);\n    cmd->redo();\n    \n    QVERIFY(!scene->items().contains(testItem));\n    QVERIFY(testItem->scene() == nullptr);\n    \n    delete cmd;\n    // Re-add for subsequent tests\n    scene->addItem(testItem);\n}\n\nvoid TestDeleteCommand::testUndoAddsItemBack()\n{\n    DeleteCommand *cmd = new DeleteCommand(testItem, scene);\n    cmd->redo();\n    QVERIFY(!scene->items().contains(testItem));\n    \n    cmd->undo();\n    QVERIFY(scene->items().contains(testItem));\n    QCOMPARE(testItem->scene(), scene);\n    \n    delete cmd;\n}\n\nvoid TestDeleteCommand::testCommandText()\n{\n    DeleteCommand *cmd = new DeleteCommand(testItem, scene);\n    QCOMPARE(cmd->text(), QString()); // Default text is empty\n    delete cmd;\n    \n    // Test with custom text\n    cmd = new DeleteCommand(testItem, scene, nullptr);\n    cmd->setText(\"Delete Item\");\n    QCOMPARE(cmd->text(), QString(\"Delete Item\"));\n    delete cmd;\n}\n\nvoid TestDeleteCommand::testSceneOwnership()\n{\n    // Create a new item for this test\n    QGraphicsRectItem *tempItem = new QGraphicsRectItem(0, 0, 50, 50);\n    scene->addItem(tempItem);\n    \n    DeleteCommand *cmd = new DeleteCommand(tempItem, scene);\n    undoStack->push(cmd);\n    \n    // After redo, item should be removed from scene\n    QVERIFY(!scene->items().contains(tempItem));\n    \n    // After undo, item should be back in scene\n    undoStack->undo();\n    QVERIFY(scene->items().contains(tempItem));\n    \n    // Cleanup\n    undoStack->clear();\n    scene->removeItem(tempItem);\n    delete tempItem;\n}\n\nQTEST_MAIN(TestDeleteCommand)\n#include \"test_deletecommand.moc\""
        },
        {
          "path": "tests/generated/test_findreplacedialog.cpp",
          "content": "#include <QtTest>\n#include <QSignalSpy>\n#include \"findreplacedialog.h\"\n\nclass TestFindReplaceDialog : public QObject\n{\n    Q_OBJECT\n\nprivate slots:\n    void initTestCase();\n    void cleanupTestCase();\n    void testConstructor();\n    void testFindLineEdit();\n    void testReplaceLineEdit();\n    void testFindButton();\n    void testReplaceButton();\n    void testReplaceAllButton();\n    void testFindSignal();\n    void testReplaceSignal();\n    void testReplaceAllSignal();\n\nprivate:\n    FindReplaceDialog *dialog;\n};\n\nvoid TestFindReplaceDialog::initTestCase()\n{\n    dialog = new FindReplaceDialog();\n}\n\nvoid TestFindReplaceDialog::cleanupTestCase()\n{\n    delete dialog;\n}\n\nvoid TestFindReplaceDialog::testConstructor()\n{\n    QVERIFY(dialog != nullptr);\n    QVERIFY(dialog->windowTitle().isEmpty() || dialog->windowTitle() == \"FindReplaceDialog\");\n}\n\nvoid TestFindReplaceDialog::testFindLineEdit()\n{\n    QLineEdit *findEdit = dialog->findChild<QLineEdit*>(QString(), Qt::FindDirectChildrenOnly);\n    QVERIFY(findEdit != nullptr);\n    QCOMPARE(findEdit->placeholderText(), QString());\n    findEdit->setText(\"test\");\n    QCOMPARE(findEdit->text(), QString(\"test\"));\n}\n\nvoid TestFindReplaceDialog::testReplaceLineEdit()\n{\n    QList<QLineEdit*> lineEdits = dialog->findChildren<QLineEdit*>();\n    QVERIFY(lineEdits.size() >= 2);\n    QLineEdit *replaceEdit = lineEdits.at(1);\n    QVERIFY(replaceEdit != nullptr);\n    replaceEdit->setText(\"replacement\");\n    QCOMPARE(replaceEdit->text(), QString(\"replacement\"));\n}\n\nvoid TestFindReplaceDialog::testFindButton()\n{\n    QPushButton *findBtn = dialog->findChild<QPushButton*>(QString(), Qt::FindDirectChildrenOnly);\n    QVERIFY(findBtn != nullptr);\n    QCOMPARE(findBtn->text(), QString(\"查找下一个\"));\n    QVERIFY(findBtn->isEnabled());\n}\n\nvoid TestFindReplaceDialog::testReplaceButton()\n{\n    QList<QPushButton*> buttons = dialog->findChildren<QPushButton*>();\n    QVERIFY(buttons.size() >= 2);\n    QPushButton *replaceBtn = buttons.at(1);\n    QVERIFY(replaceBtn != nullptr);\n    QCOMPARE(replaceBtn->text(), QString(\"替换\"));\n    QVERIFY(replaceBtn->isEnabled());\n}\n\nvoid TestFindReplaceDialog::testReplaceAllButton()\n{\n    QList<QPushButton*> buttons = dialog->findChildren<QPushButton*>();\n    QVERIFY(buttons.size() >= 3);\n    QPushButton *replaceAllBtn = buttons.at(2);\n    QVERIFY(replaceAllBtn != nullptr);\n    QCOMPARE(replaceAllBtn->text(), QString(\"全部替换\"));\n    QVERIFY(replaceAllBtn->isEnabled());\n}\n\nvoid TestFindReplaceDialog::testFindSignal()\n{\n    QSignalSpy spy(dialog, &FindReplaceDialog::findText);\n    QLineEdit *findEdit = dialog->findChild<QLineEdit*>(QString(), Qt::FindDirectChildrenOnly);\n    QPushButton *findBtn = dialog->findChild<QPushButton*>(QString(), Qt::FindDirectChildrenOnly);\n    \n    findEdit->setText(\"search term\");\n    QTest::mouseClick(findBtn, Qt::LeftButton);\n    \n    QCOMPARE(spy.count(), 1);\n    QList<QVariant> arguments = spy.takeFirst();\n    QCOMPARE(arguments.at(0).toString(), QString(\"search term\"));\n}\n\nvoid TestFindReplaceDialog::testReplaceSignal()\n{\n    QSignalSpy spy(dialog, &FindReplaceDialog::replaceText);\n    QList<QLineEdit*> lineEdits = dialog->findChildren<QLineEdit*>();\n    QList<QPushButton*> buttons = dialog->findChildren<QPushButton*>();\n    \n    QLineEdit *findEdit = lineEdits.at(0);\n    QLineEdit *replaceEdit = lineEdits.at(1);\n    QPushButton *replaceBtn = buttons.at(1);\n    \n    findEdit->setText(\"old\");\n    replaceEdit->setText(\"new\");\n    QTest::mouseClick(replaceBtn, Qt::LeftButton);\n    \n    QCOMPARE(spy.count(), 1);\n    QList<QVariant> arguments = spy.takeFirst();\n    QCOMPARE(arguments.at(0).toString(), QString(\"old\"));\n    QCOMPARE(arguments.at(1).toString(), QString(\"new\"));\n}\n\nvoid TestFindReplaceDialog::testReplaceAllSignal()\n{\n    QSignalSpy spy(dialog, &FindReplaceDialog::replaceAllText);\n    QList<QLineEdit*> lineEdits = dialog->findChildren<QLineEdit*>();\n    QList<QPushButton*> buttons = dialog->findChildren<QPushButton*>();\n    \n    QLineEdit *findEdit = lineEdits.at(0);\n    QLineEdit *replaceEdit = lineEdits.at(1);\n    QPushButton *replaceAllBtn = buttons.at(2);\n    \n    findEdit->setText(\"find\");\n    replaceEdit->setText(\"replace\");\n    QTest::mouseClick(replaceAllBtn, Qt::LeftButton);\n    \n    QCOMPARE(spy.count(), 1);\n    QList<QVariant> arguments = spy.takeFirst();\n    QCOMPARE(arguments.at(0).toString(), QString(\"find\"));\n    QCOMPARE(arguments.at(1).toString(), QString(\"replace\"));\n}\n\nQTEST_MAIN(TestFindReplaceDialog)\n#include \"test_findreplacedialog.moc\""
        },
        {
          "path": "tests/generated/test_mainwindow.cpp",
          "content": "#include <QtTest>\n#include <QMainWindow>\n#include <QTabWidget>\n#include <QGraphicsView>\n#include <QHBoxLayout>\n#include <QFile>\n#include <QTextStream>\n#include <QDebug>\n\n// 假设 MainWindow 类在 mainwindow.h 中声明\n#include \"../mainwindow.h\"\n\nclass TestMainWindow : public QObject\n{\n    Q_OBJECT\n\npublic:\n    TestMainWindow();\n    ~TestMainWindow();\n\nprivate slots:\n    void initTestCase();\n    void cleanupTestCase();\n    void testConstructor();\n    void testSaveLoadPicPath();\n    void testTabWidgetInitialization();\n    void testSceneVectorConsistency();\n    void testGlobalTabCounter();\n    void testSavePicPathFunctions();\n\nprivate:\n    MainWindow *m_mainWindow;\n};\n\nTestMainWindow::TestMainWindow()\n    : m_mainWindow(nullptr)\n{\n}\n\nTestMainWindow::~TestMainWindow()\n{\n}\n\nvoid TestMainWindow::initTestCase()\n{\n    // 创建 MainWindow 实例\n    m_mainWindow = new MainWindow();\n    QVERIFY(m_mainWindow != nullptr);\n}\n\nvoid TestMainWindow::cleanupTestCase()\n{\n    delete m_mainWindow;\n    m_mainWindow = nullptr;\n}\n\nvoid TestMainWindow::testConstructor()\n{\n    // 测试构造函数是否正确初始化了成员\n    QVERIFY(m_mainWindow->findChild<QTabWidget*>() != nullptr);\n    QVERIFY(m_mainWindow->findChild<QGraphicsView*>() != nullptr);\n    QVERIFY(m_mainWindow->findChild<QHBoxLayout*>() != nullptr);\n    \n    // 检查窗口标题\n    QCOMPARE(m_mainWindow->windowTitle(), QString(\"流程图工程界面\"));\n}\n\nvoid TestMainWindow::testSaveLoadPicPath()\n{\n    // 测试保存和加载图片路径的功能\n    QString testPath = \"/tmp/test/path\";\n    \n    // 保存路径\n    m_mainWindow->saveSavePicPath(testPath);\n    \n    // 验证文件是否创建\n    QFile file(\"lastPicLog.txt\");\n    QVERIFY(file.exists());\n    \n    // 加载路径并验证\n    QString loadedPath = m_mainWindow->loadSavePicPath();\n    QCOMPARE(loadedPath, testPath);\n    \n    // 清理测试文件\n    file.remove();\n}\n\nvoid TestMainWindow::testTabWidgetInitialization()\n{\n    // 测试标签页初始化\n    QTabWidget *tabWidget = m_mainWindow->findChild<QTabWidget*>();\n    QVERIFY(tabWidget != nullptr);\n    \n    // 初始应该有一个标签页\n    QCOMPARE(tabWidget->count(), 1);\n    \n    // 检查标签页标题格式\n    QString tabTitle = tabWidget->tabText(0);\n    QVERIFY(tabTitle.startsWith(\"新页面\"));\n}\n\nvoid TestMainWindow::testSceneVectorConsistency()\n{\n    // 测试 sceneVector 和 viewVector 的一致性\n    // 注意：这些可能是 MainWindow 的私有成员，需要将它们设为 public 或添加 getter 方法\n    // 这里假设有相应的访问方法\n    \n    // 由于无法直接访问私有成员，我们通过标签页数量来间接验证\n    QTabWidget *tabWidget = m_mainWindow->findChild<QTabWidget*>();\n    QVERIFY(tabWidget != nullptr);\n    \n    // 初始状态应该有一个标签页，对应一个场景和一个视图\n    QCOMPARE(tabWidget->count(), 1);\n}\n\nvoid TestMainWindow::testGlobalTabCounter()\n{\n    // 测试全局标签页计数器\n    // 注意：globalTabCounter 是全局变量，可能在其他测试中已被修改\n    // 这里我们主要验证它的存在和类型\n    \n    // 由于是全局变量，我们无法直接测试其值\n    // 但可以验证相关功能是否使用它\n    QTabWidget *tabWidget = m_mainWindow->findChild<QTabWidget*>();\n    QVERIFY(tabWidget != nullptr);\n    \n    // 添加新标签页应该增加计数器\n    int initialCount = tabWidget->count();\n    \n    // 注意：这里无法直接调用添加标签页的方法，因为它是私有的\n    // 我们只能验证初始状态\n    QVERIFY(initialCount >= 1);\n}\n\nvoid TestMainWindow::testSavePicPathFunctions()\n{\n    // 更全面的测试保存图片路径功能\n    \n    // 测试1：保存空路径\n    m_mainWindow->saveSavePicPath(\"\");\n    QString emptyPath = m_mainWindow->loadSavePicPath();\n    QVERIFY(emptyPath.isEmpty());\n    \n    // 测试2：保存包含特殊字符的路径\n    QString specialPath = \"/path/with spaces/and\\ttabs.txt\";\n    m_mainWindow->saveSavePicPath(specialPath);\n    QString loadedSpecialPath = m_mainWindow->loadSavePicPath();\n    QCOMPARE(loadedSpecialPath, specialPath);\n    \n    // 测试3：保存长路径\n    QString longPath = QString(\"/a/very/long/path/that/is/more/than/100/characters/\"\n                              \"in/length/to/test/the/function/properly/\"\n                              \"with/multiple/directories/and/files.txt\");\n    m_mainWindow->saveSavePicPath(longPath);\n    QString loadedLongPath = m_mainWindow->loadSavePicPath();\n    QCOMPARE(loadedLongPath, longPath);\n    \n    // 测试4：文件不存在时返回空字符串\n    QFile::remove(\"lastPicLog.txt\");\n    QString nonExistent = m_mainWindow->loadSavePicPath();\n    QVERIFY(nonExistent.isEmpty());\n}\n\nQTEST_MAIN(TestMainWindow)\n#include \"test_mainwindow.moc\"\n"
        },
        {
          "path": "tests/generated/test_geometry_utils.cpp",
          "content": "#include <QtTest>\n#include <QGraphicsItem>\n#include <QGraphicsScene>\n#include <QGraphicsView>\n#include <QPainterPath>\n#include <QPointF>\n#include <QRectF>\n#include <QSizeF>\n#include <QTransform>\n\n// 假设存在一个 geometry_utils.h 头文件，提供几何工具函数\n// 由于上下文中未明确提供 geometry_utils.h，我们创建一个占位测试来验证基本的 Qt 几何类\n// 如果 geometry_utils.h 存在，请替换 include 并添加相应的测试用例\n\nclass TestGeometryUtils : public QObject\n{\n    Q_OBJECT\n\nprivate slots:\n    void testQPointFOperations();\n    void testQRectFNormalize();\n    void testQPainterPathContains();\n    void testQTransformMapping();\n    void testDiagramPathQuadrantCalculation();\n};\n\nvoid TestGeometryUtils::testQPointFOperations()\n{\n    QPointF p1(10.5, 20.3);\n    QPointF p2(5.2, 8.7);\n    QPointF sum = p1 + p2;\n    QCOMPARE(sum.x(), 15.7);\n    QCOMPARE(sum.y(), 29.0);\n\n    QPointF diff = p1 - p2;\n    QCOMPARE(diff.x(), 5.3);\n    QCOMPARE(diff.y(), 11.6);\n\n    qreal dot = QPointF::dotProduct(p1, p2);\n    QVERIFY(qFuzzyCompare(dot, (10.5 * 5.2) + (20.3 * 8.7)));\n}\n\nvoid TestGeometryUtils::testQRectFNormalize()\n{\n    QRectF rect(100, 100, -50, -30); // 负宽度和高度\n    QRectF normalized = rect.normalized();\n    QCOMPARE(normalized.left(), 50.0);   // 100 + (-50)\n    QCOMPARE(normalized.top(), 70.0);    // 100 + (-30)\n    QCOMPARE(normalized.width(), 50.0);\n    QCOMPARE(normalized.height(), 30.0);\n}\n\nvoid TestGeometryUtils::testQPainterPathContains()\n{\n    QPainterPath path;\n    path.addEllipse(QPointF(0, 0), 50, 50); // 半径为50的圆\n    QVERIFY(path.contains(QPointF(0, 0)));\n    QVERIFY(path.contains(QPointF(30, 30)));\n    QVERIFY(!path.contains(QPointF(60, 60))); // 在圆外\n}\n\nvoid TestGeometryUtils::testQTransformMapping()\n{\n    QTransform transform;\n    transform.translate(10, 20);\n    transform.rotate(45); // 旋转45度\n    transform.scale(2, 2);\n\n    QPointF original(5, 5);\n    QPointF mapped = transform.map(original);\n    // 验证映射后的点与手动计算一致（允许浮点误差）\n    QTransform manual;\n    manual.translate(10, 20);\n    manual.rotate(45);\n    manual.scale(2, 2);\n    QPointF manualMapped = manual.map(original);\n    QVERIFY(qFuzzyCompare(mapped.x(), manualMapped.x()));\n    QVERIFY(qFuzzyCompare(mapped.y(), manualMapped.y()));\n}\n\n// 测试 DiagramPath::quad 函数（从 diagrampath.cpp 中提取的逻辑）\nvoid TestGeometryUtils::testDiagramPathQuadrantCalculation()\n{\n    // 模拟 DiagramPath::quad 函数逻辑\n    auto quad = [](QPointF startPoint, QPointF endPoint) -> int {\n        if (startPoint.x() >= endPoint.x() && startPoint.y() >= endPoint.y()) {\n            return 4;\n        } else if (startPoint.x() <= endPoint.x() && startPoint.y() >= endPoint.y()) {\n            return 1;\n        } else if (startPoint.x() >= endPoint.x() && startPoint.y() <= endPoint.y()) {\n            return 3;\n        } else if (startPoint.x() <= endPoint.x() && startPoint.y() <= endPoint.y()) {\n            return 2;\n        } else {\n            return 0;\n        }\n    };\n\n    QCOMPARE(quad(QPointF(10, 10), QPointF(5, 5)), 4);   // 第四象限\n    QCOMPARE(quad(QPointF(5, 10), QPointF(10, 5)), 1);   // 第一象限\n    QCOMPARE(quad(QPointF(10, 5), QPointF(5, 10)), 3);   // 第三象限\n    QCOMPARE(quad(QPointF(5, 5), QPointF(10, 10)), 2);   // 第二象限\n    QCOMPARE(quad(QPointF(5, 5), QPointF(5, 5)), 4);     // 相等点，按第一个条件\n}\n\nQTEST_MAIN(TestGeometryUtils)\n#include \"test_geometry_utils.moc\""
        },
        {
          "path": "tests/generated/test_item_selection.cpp",
          "content": "#include <QtTest>\n#include <QGraphicsScene>\n#include <QGraphicsView>\n#include <QGraphicsItem>\n#include <QMenu>\n#include \"../diagramscene.h\"\n#include \"../diagramitem.h\"\n#include \"../diagramtextitem.h\"\n\nclass TestItemSelection : public QObject\n{\n    Q_OBJECT\n\nprivate slots:\n    void initTestCase();\n    void cleanupTestCase();\n    void testSingleItemSelection();\n    void testMultipleItemSelection();\n    void testSelectionClearsOnClickEmptyArea();\n    void testItemSelectedSignal();\n    void testTextItemSelection();\n    void testSelectionWithShiftDrag();\n    void testSelectedItemsList();\n\nprivate:\n    DiagramScene *scene;\n    QMenu *dummyMenu;\n    QGraphicsView *view;\n};\n\nvoid TestItemSelection::initTestCase()\n{\n    dummyMenu = new QMenu();\n    scene = new DiagramScene(dummyMenu);\n    view = new QGraphicsView(scene);\n    view->show(); // Needed for some item operations\n}\n\nvoid TestItemSelection::cleanupTestCase()\n{\n    delete view;\n    delete scene;\n    delete dummyMenu;\n}\n\nvoid TestItemSelection::testSingleItemSelection()\n{\n    DiagramItem *item = new DiagramItem(DiagramItem::Step, dummyMenu);\n    scene->addItem(item);\n    item->setPos(100, 100);\n\n    // Initially not selected\n    QVERIFY(!item->isSelected());\n\n    // Select the item\n    item->setSelected(true);\n    QVERIFY(item->isSelected());\n\n    // Verify scene's selected items contains it\n    QList<QGraphicsItem *> selected = scene->selectedItems();\n    QCOMPARE(selected.size(), 1);\n    QVERIFY(selected.contains(item));\n\n    scene->removeItem(item);\n    delete item;\n}\n\nvoid TestItemSelection::testMultipleItemSelection()\n{\n    DiagramItem *item1 = new DiagramItem(DiagramItem::Step, dummyMenu);\n    DiagramItem *item2 = new DiagramItem(DiagramItem::Conditional, dummyMenu);\n    scene->addItem(item1);\n    scene->addItem(item2);\n    item1->setPos(50, 50);\n    item2->setPos(200, 200);\n\n    // Select both\n    item1->setSelected(true);\n    item2->setSelected(true);\n\n    QVERIFY(item1->isSelected());\n    QVERIFY(item2->isSelected());\n\n    QList<QGraphicsItem *> selected = scene->selectedItems();\n    QCOMPARE(selected.size(), 2);\n    QVERIFY(selected.contains(item1));\n    QVERIFY(selected.contains(item2));\n\n    scene->removeItem(item1);\n    scene->removeItem(item2);\n    delete item1;\n    delete item2;\n}\n\nvoid TestItemSelection::testSelectionClearsOnClickEmptyArea()\n{\n    DiagramItem *item = new DiagramItem(DiagramItem::Step, dummyMenu);\n    scene->addItem(item);\n    item->setPos(100, 100);\n    item->setSelected(true);\n    QVERIFY(item->isSelected());\n\n    // Simulate clicking empty area by clearing selection via scene\n    scene->clearSelection();\n    QVERIFY(!item->isSelected());\n    QVERIFY(scene->selectedItems().isEmpty());\n\n    scene->removeItem(item);\n    delete item;\n}\n\nvoid TestItemSelection::testItemSelectedSignal()\n{\n    DiagramItem *item = new DiagramItem(DiagramItem::Step, dummyMenu);\n    scene->addItem(item);\n    item->setPos(150, 150);\n\n    QSignalSpy spy(scene, &DiagramScene::itemSelected);\n\n    item->setSelected(true);\n    // The signal is emitted when selection changes; we can at least verify no crash\n    QVERIFY(spy.count() >= 0); // Just ensure signal connection works\n\n    scene->removeItem(item);\n    delete item;\n}\n\nvoid TestItemSelection::testTextItemSelection()\n{\n    DiagramTextItem *textItem = new DiagramTextItem();\n    scene->addItem(textItem);\n    textItem->setPos(300, 300);\n    textItem->setPlainText(\"Test\");\n\n    textItem->setSelected(true);\n    QVERIFY(textItem->isSelected());\n    QVERIFY(scene->selectedItems().contains(textItem));\n\n    scene->removeItem(textItem);\n    delete textItem;\n}\n\nvoid TestItemSelection::testSelectionWithShiftDrag()\n{\n    // This tests the shift-drag selection mode mentioned in mousePressEvent\n    DiagramItem *item1 = new DiagramItem(DiagramItem::Step, dummyMenu);\n    DiagramItem *item2 = new DiagramItem(DiagramItem::Conditional, dummyMenu);\n    scene->addItem(item1);\n    scene->addItem(item2);\n    item1->setPos(50, 50);\n    item2->setPos(250, 250);\n\n    // Clear any existing selection\n    scene->clearSelection();\n    QVERIFY(scene->selectedItems().isEmpty());\n\n    // Simulate shift-drag by setting mode and selecting a rectangle\n    // Since we can't simulate mouse events easily, we directly test the selection logic\n    // by selecting both items and verifying.\n    item1->setSelected(true);\n    item2->setSelected(true);\n\n    QList<QGraphicsItem *> selected = scene->selectedItems();\n    QCOMPARE(selected.size(), 2);\n\n    scene->removeItem(item1);\n    scene->removeItem(item2);\n    delete item1;\n    delete item2;\n}\n\nvoid TestItemSelection::testSelectedItemsList()\n{\n    // Ensure selectedItems() returns only selected items\n    DiagramItem *item1 = new DiagramItem(DiagramItem::Step, dummyMenu);\n    DiagramItem *item2 = new DiagramItem(DiagramItem::Conditional, dummyMenu);\n    DiagramItem *item3 = new DiagramItem(DiagramItem::StartEnd, dummyMenu);\n    scene->addItem(item1);\n    scene->addItem(item2);\n    scene->addItem(item3);\n    item1->setPos(10, 10);\n    item2->setPos(100, 100);\n    item3->setPos(200, 200);\n\n    item1->setSelected(true);\n    item3->setSelected(true);\n    item2->setSelected(false);\n\n    QList<QGraphicsItem *> selected = scene->selectedItems();\n    QCOMPARE(selected.size(), 2);\n    QVERIFY(selected.contains(item1));\n    QVERIFY(selected.contains(item3));\n    QVERIFY(!selected.contains(item2));\n\n    scene->removeItem(item1);\n    scene->removeItem(item2);\n    scene->removeItem(item3);\n    delete item1;\n    delete item2;\n    delete item3;\n}\n\nQTEST_MAIN(TestItemSelection)\n#include \"test_item_selection.moc\"\n"
        },
        {
          "path": "tests/generated/test_z_order.cpp",
          "content": "#include <QtTest>\n#include <QGraphicsScene>\n#include <QGraphicsItem>\n#include \"diagramitem.h\"\n#include \"diagrampath.h\"\n#include \"diagramitemgroup.h\"\n\nclass TestZOrder : public QObject\n{\n    Q_OBJECT\n\nprivate slots:\n    void testDiagramItemZOrder();\n    void testDiagramPathZOrder();\n    void testDiagramItemGroupZOrder();\n    void testSceneItemStackingOrder();\n};\n\nvoid TestZOrder::testDiagramItemZOrder()\n{\n    QGraphicsScene scene;\n    DiagramItem *item1 = new DiagramItem(DiagramItem::Step, nullptr);\n    DiagramItem *item2 = new DiagramItem(DiagramItem::Conditional, nullptr);\n    DiagramItem *item3 = new DiagramItem(DiagramItem::StartEnd, nullptr);\n\n    scene.addItem(item1);\n    scene.addItem(item2);\n    scene.addItem(item3);\n\n    // 默认 Z 值应为 0\n    QCOMPARE(item1->zValue(), 0.0);\n    QCOMPARE(item2->zValue(), 0.0);\n    QCOMPARE(item3->zValue(), 0.0);\n\n    // 设置不同 Z 值\n    item1->setZValue(1.0);\n    item2->setZValue(2.0);\n    item3->setZValue(3.0);\n\n    QCOMPARE(item1->zValue(), 1.0);\n    QCOMPARE(item2->zValue(), 2.0);\n    QCOMPARE(item3->zValue(), 3.0);\n\n    // 验证场景中的项顺序（按 Z 值排序）\n    QList<QGraphicsItem *> items = scene.items(Qt::DescendingOrder);\n    QVERIFY(items.indexOf(item3) < items.indexOf(item2));\n    QVERIFY(items.indexOf(item2) < items.indexOf(item1));\n\n    delete item1;\n    delete item2;\n    delete item3;\n}\n\nvoid TestZOrder::testDiagramPathZOrder()\n{\n    QGraphicsScene scene;\n    DiagramItem *startItem = new DiagramItem(DiagramItem::Step, nullptr);\n    DiagramItem *endItem = new DiagramItem(DiagramItem::Conditional, nullptr);\n    scene.addItem(startItem);\n    scene.addItem(endItem);\n\n    DiagramPath *path = new DiagramPath(startItem, endItem, DiagramItem::TF_Right, DiagramItem::TF_Left);\n    scene.addItem(path);\n\n    // DiagramPath 默认 Z 值应为 0\n    QCOMPARE(path->zValue(), 0.0);\n\n    // 路径应位于图形项之下（通常连接线在底层）\n    path->setZValue(-1.0);\n    QCOMPARE(path->zValue(), -1.0);\n\n    // 验证场景项顺序\n    QList<QGraphicsItem *> items = scene.items(Qt::DescendingOrder);\n    int pathIndex = items.indexOf(path);\n    int startIndex = items.indexOf(startItem);\n    int endIndex = items.indexOf(endItem);\n    QVERIFY(pathIndex > startIndex || pathIndex > endIndex); // Z 值更小，索引更大\n\n    delete startItem;\n    delete endItem;\n    delete path;\n}\n\nvoid TestZOrder::testDiagramItemGroupZOrder()\n{\n    QGraphicsScene scene;\n    DiagramItemGroup *group = new DiagramItemGroup();\n    DiagramItem *child1 = new DiagramItem(DiagramItem::Step, nullptr);\n    DiagramItem *child2 = new DiagramItem(DiagramItem::Conditional, nullptr);\n\n    scene.addItem(group);\n    scene.addItem(child1);\n    scene.addItem(child2);\n\n    // 添加子项到组，组的 Z 值应高于子项\n    group->addItem(child1);\n    group->addItem(child2);\n\n    // 验证 addItem 中设置的 Z 值关系\n    QVERIFY(child1->zValue() < group->zValue());\n    QVERIFY(child2->zValue() < group->zValue());\n\n    // 设置组 Z 值，子项应保持相对关系\n    group->setZValue(5.0);\n    QCOMPARE(group->zValue(), 5.0);\n    QVERIFY(child1->zValue() < 5.0);\n    QVERIFY(child2->zValue() < 5.0);\n\n    delete group;\n    delete child1;\n    delete child2;\n}\n\nvoid TestZOrder::testSceneItemStackingOrder()\n{\n    QGraphicsScene scene;\n    DiagramItem *item = new DiagramItem(DiagramItem::Step, nullptr);\n    DiagramTextItem *textItem = new DiagramTextItem();\n    DiagramItemGroup *group = new DiagramItemGroup();\n\n    scene.addItem(item);\n    scene.addItem(textItem);\n    scene.addItem(group);\n\n    // 设置不同的 Z 值模拟典型层叠\n    item->setZValue(0.0);      // 图形底层\n    textItem->setZValue(1.0);  // 文本在图形之上\n    group->setZValue(2.0);     // 组在最顶层\n\n    // 验证场景 items() 排序\n    QList<QGraphicsItem *> items = scene.items(Qt::DescendingOrder);\n    QCOMPARE(items.at(0), group);\n    QCOMPARE(items.at(1), textItem);\n    QCOMPARE(items.at(2), item);\n\n    // 改变顺序\n    item->setZValue(3.0);\n    items = scene.items(Qt::DescendingOrder);\n    QCOMPARE(items.at(0), item);\n    QCOMPARE(items.at(1), group);\n    QCOMPARE(items.at(2), textItem);\n\n    delete item;\n    delete textItem;\n    delete group;\n}\n\nQTEST_MAIN(TestZOrder)\n#include \"test_z_order.moc\""
        },
        {
          "path": "tests/generated/test_scene_serialization.cpp",
          "content": "#include <QtTest>\n#include <QMenu>\n#include <QPixmap>\n#include <QGraphicsScene>\n#include <QGraphicsItem>\n#include <QGraphicsRectItem>\n#include <QGraphicsEllipseItem>\n#include <QGraphicsTextItem>\n#include <QJsonDocument>\n#include <QJsonObject>\n#include <QJsonArray>\n#include <QBuffer>\n#include <QDataStream>\n#include \"../diagramscene.h\"\n#include \"../diagramitem.h\"\n#include \"../diagramtextitem.h\"\n#include \"../arrow.h\"\n#include \"../diagrampath.h\"\n\nclass TestSceneSerialization : public QObject\n{\n    Q_OBJECT\n\nprivate slots:\n    void initTestCase();\n    void cleanupTestCase();\n    void testEmptySceneSerialization();\n    void testSceneWithItemsSerialization();\n    void testSceneWithArrowsSerialization();\n    void testSceneWithTextItemsSerialization();\n    void testSceneWithPathsSerialization();\n    void testSceneRoundTrip();\n    void testItemPropertiesPreserved();\n    void testSceneBackgroundBrush();\n    void testSceneSelectionState();\n    void testSceneItemOrder();\n\nprivate:\n    DiagramScene *scene;\n    QMenu *dummyMenu;\n    QColor testColor;\n    QFont testFont;\n};\n\nvoid TestSceneSerialization::initTestCase()\n{\n    dummyMenu = new QMenu();\n    scene = new DiagramScene(dummyMenu);\n    scene->setSceneRect(QRectF(0, 0, 1000, 1000));\n    testColor = QColor(255, 200, 100, 150);\n    testFont = QFont(\"Arial\", 12, QFont::Bold);\n}\n\nvoid TestSceneSerialization::cleanupTestCase()\n{\n    delete scene;\n    delete dummyMenu;\n}\n\nvoid TestSceneSerialization::testEmptySceneSerialization()\n{\n    QVERIFY(scene != nullptr);\n    QCOMPARE(scene->items().size(), 0);\n    \n    // Test that scene properties are set\n    QCOMPARE(scene->sceneRect(), QRectF(0, 0, 1000, 1000));\n}\n\nvoid TestSceneSerialization::testSceneWithItemsSerialization()\n{\n    // Clear scene first\n    scene->clear();\n    \n    // Add different types of diagram items\n    DiagramItem *stepItem = new DiagramItem(DiagramItem::Step, dummyMenu);\n    stepItem->setPos(100, 100);\n    stepItem->setBrush(testColor);\n    scene->addItem(stepItem);\n    \n    DiagramItem *conditionalItem = new DiagramItem(DiagramItem::Conditional, dummyMenu);\n    conditionalItem->setPos(300, 300);\n    conditionalItem->setBrush(Qt::blue);\n    scene->addItem(conditionalItem);\n    \n    DiagramItem *circularItem = new DiagramItem(DiagramItem::circular, dummyMenu);\n    circularItem->setPos(500, 500);\n    circularItem->setBrush(Qt::green);\n    scene->addItem(circularItem);\n    \n    QCOMPARE(scene->items().size(), 3);\n    \n    // Verify items are of correct type\n    QList<QGraphicsItem*> items = scene->items();\n    int diagramItemCount = 0;\n    for (QGraphicsItem *item : items) {\n        if (qgraphicsitem_cast<DiagramItem*>(item)) {\n            diagramItemCount++;\n        }\n    }\n    QCOMPARE(diagramItemCount, 3);\n}\n\nvoid TestSceneSerialization::testSceneWithArrowsSerialization()\n{\n    scene->clear();\n    \n    // Create two items and connect them with an arrow\n    DiagramItem *startItem = new DiagramItem(DiagramItem::Step, dummyMenu);\n    startItem->setPos(100, 100);\n    scene->addItem(startItem);\n    \n    DiagramItem *endItem = new DiagramItem(DiagramItem::Step, dummyMenu);\n    endItem->setPos(300, 300);\n    scene->addItem(endItem);\n    \n    Arrow *arrow = new Arrow(startItem, endItem);\n    arrow->setColor(Qt::red);\n    scene->addItem(arrow);\n    \n    QCOMPARE(scene->items().size(), 3);\n    \n    // Verify arrow connects the correct items\n    QCOMPARE(arrow->startItem(), startItem);\n    QCOMPARE(arrow->endItem(), endItem);\n}\n\nvoid TestSceneSerialization::testSceneWithTextItemsSerialization()\n{\n    scene->clear();\n    \n    DiagramTextItem *textItem = new DiagramTextItem();\n    textItem->setPlainText(\"Test Text\");\n    textItem->setDefaultTextColor(Qt::darkBlue);\n    textItem->setFont(testFont);\n    textItem->setPos(200, 200);\n    scene->addItem(textItem);\n    \n    QCOMPARE(scene->items().size(), 1);\n    \n    DiagramTextItem *retrievedItem = qgraphicsitem_cast<DiagramTextItem*>(scene->items().first());\n    QVERIFY(retrievedItem != nullptr);\n    QCOMPARE(retrievedItem->toPlainText(), QString(\"Test Text\"));\n    QCOMPARE(retrievedItem->defaultTextColor(), QColor(Qt::darkBlue));\n}\n\nvoid TestSceneSerialization::testSceneWithPathsSerialization()\n{\n    scene->clear();\n    \n    // Create items for path connection\n    DiagramItem *startItem = new DiagramItem(DiagramItem::Step, dummyMenu);\n    startItem->setPos(100, 100);\n    scene->addItem(startItem);\n    \n    DiagramItem *endItem = new DiagramItem(DiagramItem::Step, dummyMenu);\n    endItem->setPos(400, 400);\n    scene->addItem(endItem);\n    \n    // Note: DiagramPath requires specific TransformState values\n    // Using default states for testing\n    DiagramPath *path = new DiagramPath(startItem, endItem, \n                                        DiagramItem::TF_Right, \n                                        DiagramItem::TF_Left);\n    scene->addItem(path);\n    \n    QCOMPARE(scene->items().size(), 3);\n    \n    // Verify path connects correct items\n    QCOMPARE(path->getStartItem(), startItem);\n    QCOMPARE(path->getEndItem(), endItem);\n}\n\nvoid TestSceneSerialization::testSceneRoundTrip()\n{\n    scene->clear();\n    \n    // Create a complex scene\n    DiagramItem *item1 = new DiagramItem(DiagramItem::Step, dummyMenu);\n    item1->setPos(50, 50);\n    item1->setBrush(QColor(255, 0, 0, 128));\n    scene->addItem(item1);\n    \n    DiagramItem *item2 = new DiagramItem(DiagramItem::Conditional, dummyMenu);\n    item2->setPos(250, 150);\n    item2->setBrush(QColor(0, 255, 0, 128));\n    scene->addItem(item2);\n    \n    Arrow *arrow = new Arrow(item1, item2);\n    arrow->setColor(Qt::darkGreen);\n    scene->addItem(arrow);\n    \n    DiagramTextItem *textItem = new DiagramTextItem();\n    textItem->setPlainText(\"Round Trip Test\");\n    textItem->setPos(150, 250);\n    scene->addItem(textItem);\n    \n    // Store original state\n    int originalItemCount = scene->items().size();\n    QRectF originalSceneRect = scene->sceneRect();\n    \n    // Simulate serialization by checking item properties persist\n    QList<QGraphicsItem*> items = scene->items();\n    \n    // Verify all items are still present\n    QCOMPARE(items.size(), originalItemCount);\n    \n    // Verify scene rect unchanged\n    QCOMPARE(scene->sceneRect(), originalSceneRect);\n}\n\nvoid TestSceneSerialization::testItemPropertiesPreserved()\n{\n    scene->clear();\n    \n    DiagramItem *item = new DiagramItem(DiagramItem::Step, dummyMenu);\n    QSizeF originalSize(200, 150);\n    item->setFixedSize(originalSize);\n    item->setPos(100, 100);\n    item->setBrush(testColor);\n    item->setRotationAngle(45);\n    scene->addItem(item);\n    \n    // Verify properties are set correctly\n    QCOMPARE(item->pos(), QPointF(100, 100));\n    QCOMPARE(item->rotationAngle(), 45.0);\n    \n    // Note: getSize() method not shown in provided code, assuming it exists\n    // If not, this test would need adjustment\n    // QCOMPARE(item->getSize(), originalSize);\n}\n\nvoid TestSceneSerialization::testSceneBackgroundBrush()\n{\n    QPixmap bgPixmap(100, 100);\n    bgPixmap.fill(Qt::lightGray);\n    scene->setBackgroundBrush(bgPixmap);\n    \n    // Verify background brush is set\n    QVERIFY(!scene->backgroundBrush().texture().isNull());\n}\n\nvoid TestSceneSerialization::testSceneSelectionState()\n{\n    scene->clear();\n    \n    DiagramItem *item1 = new DiagramItem(DiagramItem::Step, dummyMenu);\n    item1->setPos(100, 100);\n    scene->addItem(item1);\n    \n    DiagramItem *item2 = new DiagramItem(DiagramItem::Step, dummyMenu);\n    item2->setPos(300, 300);\n    scene->addItem(item2);\n    \n    // Select first item\n    item1->setSelected(true);\n    \n    // Verify selection state\n    QVERIFY(item1->isSelected());\n    QVERIFY(!item2->isSelected());\n    \n    // Verify scene selection count\n    QCOMPARE(scene->selectedItems().size(), 1);\n    QCOMPARE(scene->selectedItems().first(), static_cast<QGraphicsItem*>(item1));\n}\n\nvoid TestSceneSerialization::testSceneItemOrder()\n{\n    scene->clear();\n    \n    // Add items in specific order\n    DiagramItem *item1 = new DiagramItem(DiagramItem::Step, dummyMenu);\n    item1->setPos(100, 100);\n    item1->setZValue(1.0);\n    scene->addItem(item1);\n    \n    DiagramItem *item2 = new DiagramItem(DiagramItem::Step, dummyMenu);\n    item2->setPos(150, 150);\n    item2->setZValue(2.0);  // Higher z-value should appear on top\n    scene->addItem(item2);\n    \n    DiagramTextItem *textItem = new DiagramTextItem();\n    textItem->setPlainText(\"Top Text\");\n    textItem->setPos(200, 200);\n    textItem->setZValue(3.0);  // Highest z-value\n    scene->addItem(textItem);\n    \n    // Verify z-order\n    QList<QGraphicsItem*> items = scene->items();\n    QVERIFY(items.size() >= 3);\n    \n    // Items should be returned in stacking order (top-most first)\n    // Text item with highest z-value should be first\n    QGraphicsItem *topItem = items.first();\n    DiagramTextItem *topTextItem = qgraphicsitem_cast<DiagramTextItem*>(topItem);\n    QVERIFY(topTextItem != nullptr);\n    QCOMPARE(topTextItem->toPlainText(), QString(\"Top Text\"));\n}\n\nQTEST_MAIN(TestSceneSerialization)\n#include \"test_scene_serialization.moc\""
        },
        {
          "path": "tests/generated/test_command_pattern.cpp",
          "content": "#include <QtTest>\n#include <QMenu>\n#include \"deletecommand.h\"\n#include \"diagramitem.h\"\n#include \"diagramscene.h\"\n#include <QGraphicsScene>\n#include <QUndoStack>\n\nclass TestCommandPattern : public QObject\n{\n    Q_OBJECT\n\nprivate slots:\n    void initTestCase();\n    void cleanupTestCase();\n    void testDeleteCommandCreation();\n    void testDeleteCommandRedo();\n    void testDeleteCommandUndo();\n    void testDeleteCommandIntegrationWithUndoStack();\n\nprivate:\n    QGraphicsScene *scene;\n    DiagramItem *item;\n    QUndoStack *undoStack;\n};\n\nvoid TestCommandPattern::initTestCase()\n{\n    scene = new QGraphicsScene();\n    QMenu *dummyMenu = new QMenu();\n    item = new DiagramItem(DiagramItem::Step, dummyMenu);\n    scene->addItem(item);\n    undoStack = new QUndoStack();\n}\n\nvoid TestCommandPattern::cleanupTestCase()\n{\n    delete undoStack;\n    delete scene;\n}\n\nvoid TestCommandPattern::testDeleteCommandCreation()\n{\n    DeleteCommand *cmd = new DeleteCommand(item, scene);\n    QVERIFY(cmd != nullptr);\n    QCOMPARE(cmd->text(), QString());\n    delete cmd;\n}\n\nvoid TestCommandPattern::testDeleteCommandRedo()\n{\n    QVERIFY(scene->items().contains(item));\n    DeleteCommand cmd(item, scene);\n    cmd.redo();\n    QVERIFY(!scene->items().contains(item));\n}\n\nvoid TestCommandPattern::testDeleteCommandUndo()\n{\n    DeleteCommand cmd(item, scene);\n    cmd.redo();\n    QVERIFY(!scene->items().contains(item));\n    cmd.undo();\n    QVERIFY(scene->items().contains(item));\n    QCOMPARE(item->pos(), cmd.m_itemPos);\n}\n\nvoid TestCommandPattern::testDeleteCommandIntegrationWithUndoStack()\n{\n    QVERIFY(scene->items().contains(item));\n    DeleteCommand *cmd = new DeleteCommand(item, scene);\n    undoStack->push(cmd);\n    QVERIFY(!scene->items().contains(item));\n    undoStack->undo();\n    QVERIFY(scene->items().contains(item));\n    undoStack->redo();\n    QVERIFY(!scene->items().contains(item));\n    undoStack->undo();\n    QVERIFY(scene->items().contains(item));\n}\n\nQTEST_MAIN(TestCommandPattern)\n#include \"test_command_pattern.moc\""
        },
        {
          "path": "tests/generated/test_bounding_boxes.cpp",
          "content": "#include <QtTest>\n#include <QMenu>\n#include <QGraphicsScene>\n#include <QGraphicsView>\n#include \"../diagramitem.h\"\n#include \"../diagramitemgroup.h\"\n#include \"../diagrampath.h\"\n\nclass TestBoundingBoxes : public QObject\n{\n    Q_OBJECT\n\nprivate slots:\n    void initTestCase();\n    void cleanupTestCase();\n    void testDiagramItemBoundingRect();\n    void testDiagramItemGroupBoundingRect();\n    void testDiagramPathBoundingRect();\n    void testDiagramItemRotationBoundingRect();\n    void testDiagramItemSetFixedSize();\n\nprivate:\n    QGraphicsScene *scene;\n    QGraphicsView *view;\n    QMenu *dummyMenu;\n};\n\nvoid TestBoundingBoxes::initTestCase()\n{\n    scene = new QGraphicsScene();\n    view = new QGraphicsView(scene);\n    dummyMenu = new QMenu();\n}\n\nvoid TestBoundingBoxes::cleanupTestCase()\n{\n    delete view;\n    delete scene;\n    delete dummyMenu;\n}\n\nvoid TestBoundingBoxes::testDiagramItemBoundingRect()\n{\n    DiagramItem *item = new DiagramItem(DiagramItem::Step, dummyMenu);\n    scene->addItem(item);\n    \n    QRectF rect = item->boundingRect();\n    QVERIFY2(rect.isValid(), \"Bounding rect should be valid\");\n    QVERIFY2(rect.width() > 0 && rect.height() > 0, \"Bounding rect should have positive dimensions\");\n    \n    // Test that the bounding rect is larger than the core graphics size due to border/rotation handling\n    QSizeF itemSize = item->getSize();\n    QVERIFY2(rect.width() >= itemSize.width() && rect.height() >= itemSize.height(), \n             \"Bounding rect should encompass the item's graphical size\");\n    \n    delete item;\n}\n\nvoid TestBoundingBoxes::testDiagramItemGroupBoundingRect()\n{\n    // Create a group and add some items to it\n    DiagramItemGroup *group = new DiagramItemGroup();\n    scene->addItem(group);\n    \n    DiagramItem *item1 = new DiagramItem(DiagramItem::Step, dummyMenu);\n    item1->setPos(50, 50);\n    DiagramItem *item2 = new DiagramItem(DiagramItem::Conditional, dummyMenu);\n    item2->setPos(200, 100);\n    \n    // Add items to the group\n    group->addItem(item1);\n    group->addItem(item2);\n    \n    QRectF groupRect = group->boundingRect();\n    QVERIFY2(groupRect.isValid(), \"Group bounding rect should be valid\");\n    \n    // The group's bounding rect should encompass both items\n    QRectF item1Rect = item1->boundingRect().translated(item1->pos());\n    QRectF item2Rect = item2->boundingRect().translated(item2->pos());\n    QRectF combinedRect = item1Rect.united(item2Rect);\n    \n    // Adjust for group's internal coordinate system (top-left calculation)\n    QPointF groupTopLeft = group->getTopLeft();\n    QRectF expectedGroupRect = combinedRect.translated(-groupTopLeft);\n    \n    QVERIFY2(qFuzzyCompare(groupRect.x(), expectedGroupRect.x()) && \n             qFuzzyCompare(groupRect.y(), expectedGroupRect.y()) &&\n             qFuzzyCompare(groupRect.width(), expectedGroupRect.width()) &&\n             qFuzzyCompare(groupRect.height(), expectedGroupRect.height()),\n             \"Group bounding rect should correctly encompass all child items\");\n    \n    delete group; // Items are deleted as children\n}\n\nvoid TestBoundingBoxes::testDiagramPathBoundingRect()\n{\n    // Create two items and a path between them\n    DiagramItem *startItem = new DiagramItem(DiagramItem::Step, dummyMenu);\n    DiagramItem *endItem = new DiagramItem(DiagramItem::Conditional, dummyMenu);\n    \n    startItem->setPos(0, 0);\n    endItem->setPos(300, 200);\n    \n    scene->addItem(startItem);\n    scene->addItem(endItem);\n    \n    DiagramPath *path = new DiagramPath(startItem, endItem, \n                                        DiagramItem::TF_Right, \n                                        DiagramItem::TF_Left);\n    scene->addItem(path);\n    \n    // Update the path to calculate its geometry\n    path->updatePath();\n    \n    QPainterPath painterPath = path->path();\n    QRectF pathRect = painterPath.boundingRect();\n    \n    QVERIFY2(pathRect.isValid(), \"Path bounding rect should be valid\");\n    QVERIFY2(pathRect.width() > 0 || pathRect.height() > 0, \n             \"Path should have some dimension\");\n    \n    // The path should be between the two items\n    QVERIFY2(pathRect.left() >= qMin(startItem->pos().x(), endItem->pos().x()) - 50 &&\n             pathRect.right() <= qMax(startItem->pos().x(), endItem->pos().x()) + 50,\n             \"Path should be horizontally between the items\");\n    \n    delete path;\n    delete startItem;\n    delete endItem;\n}\n\nvoid TestBoundingBoxes::testDiagramItemRotationBoundingRect()\n{\n    DiagramItem *item = new DiagramItem(DiagramItem::Step, dummyMenu);\n    scene->addItem(item);\n    \n    QRectF originalRect = item->boundingRect();\n    \n    // Apply rotation\n    item->setRotationAngle(45);\n    QRectF rotatedRect = item->boundingRect();\n    \n    // Rotated bounding rect should be larger or equal in area\n    qreal originalArea = originalRect.width() * originalRect.height();\n    qreal rotatedArea = rotatedRect.width() * rotatedRect.height();\n    \n    QVERIFY2(rotatedArea >= originalArea - 0.001, \n             \"Rotated bounding rect should have equal or larger area\");\n    \n    // Test multiple rotations\n    item->setRotationAngle(90);\n    QRectF rect90 = item->boundingRect();\n    QVERIFY2(rect90.isValid(), \"90-degree rotation should produce valid bounding rect\");\n    \n    item->setRotationAngle(180);\n    QRectF rect180 = item->boundingRect();\n    QVERIFY2(rect180.isValid(), \"180-degree rotation should produce valid bounding rect\");\n    \n    delete item;\n}\n\nvoid TestBoundingBoxes::testDiagramItemSetFixedSize()\n{\n    DiagramItem *item = new DiagramItem(DiagramItem::Step, dummyMenu);\n    scene->addItem(item);\n    \n    QSizeF originalSize = item->getSize();\n    QRectF originalRect = item->boundingRect();\n    \n    // Set a new size\n    QSizeF newSize(200, 150);\n    item->setFixedSize(newSize);\n    \n    QSizeF currentSize = item->getSize();\n    QRectF newRect = item->boundingRect();\n    \n    QVERIFY2(qFuzzyCompare(currentSize.width(), newSize.width()) &&\n             qFuzzyCompare(currentSize.height(), newSize.height()),\n             \"setFixedSize should correctly update the item size\");\n    \n    // Bounding rect should reflect the new size\n    QVERIFY2(newRect.width() >= newSize.width() && newRect.height() >= newSize.height(),\n             \"Bounding rect should encompass the new size\");\n    \n    // Test with minimum size constraint\n    QSizeF minSize(40, 40);\n    item->setFixedSize(minSize);\n    QSizeF minSizeResult = item->getSize();\n    QVERIFY2(minSizeResult.width() >= minSize.width() && \n             minSizeResult.height() >= minSize.height(),\n             \"Item should respect minimum size constraints\");\n    \n    delete item;\n}\n\nQTEST_MAIN(TestBoundingBoxes)\n#include \"test_bounding_boxes.moc\""
        },
        {
          "path": "tests/generated/test_item_transformations.cpp",
          "content": "#include <QtTest>\n#include <QGraphicsScene>\n#include <QMenu>\n#include \"../diagramitem.h\"\n#include \"../diagrampath.h\"\n\nclass TestItemTransformations : public QObject\n{\n    Q_OBJECT\n\nprivate slots:\n    void initTestCase();\n    void cleanupTestCase();\n    void testDiagramItemRotation();\n    void testDiagramItemSize();\n    void testDiagramItemColor();\n    void testDiagramPathQuadrantCalculation();\n    void testDiagramPathUpdate();\n    void testDiagramItemGroupAddItem();\n\nprivate:\n    QGraphicsScene *scene;\n    QMenu *dummyMenu;\n};\n\nvoid TestItemTransformations::initTestCase()\n{\n    scene = new QGraphicsScene();\n    dummyMenu = new QMenu();\n}\n\nvoid TestItemTransformations::cleanupTestCase()\n{\n    delete dummyMenu;\n    delete scene;\n}\n\nvoid TestItemTransformations::testDiagramItemRotation()\n{\n    DiagramItem *item = new DiagramItem(DiagramItem::Step, dummyMenu);\n    scene->addItem(item);\n    \n    // Test initial rotation\n    QCOMPARE(item->rotationAngle(), 0.0);\n    \n    // Test setting rotation\n    item->setRotationAngle(45.0);\n    QCOMPARE(item->rotationAngle(), 45.0);\n    \n    // Test rotation bounds (should wrap or clamp if implemented)\n    item->setRotationAngle(370.0);\n    // Assuming rotationAngle() returns the stored value directly\n    QCOMPARE(item->rotationAngle(), 370.0);\n    \n    delete item;\n}\n\nvoid TestItemTransformations::testDiagramItemSize()\n{\n    DiagramItem *item = new DiagramItem(DiagramItem::Step, dummyMenu);\n    scene->addItem(item);\n    \n    // Test initial size\n    QSizeF initialSize = item->getSize();\n    QVERIFY(initialSize.width() > 0 && initialSize.height() > 0);\n    \n    // Test setting fixed size\n    QSizeF newSize(200, 150);\n    item->setFixedSize(newSize);\n    QCOMPARE(item->getSize(), newSize);\n    \n    // Test bounding rect updates with size\n    QRectF bounds = item->boundingRect();\n    QVERIFY(bounds.width() >= newSize.width());\n    QVERIFY(bounds.height() >= newSize.height());\n    \n    delete item;\n}\n\nvoid TestItemTransformations::testDiagramItemColor()\n{\n    DiagramItem *item = new DiagramItem(DiagramItem::Step, dummyMenu);\n    scene->addItem(item);\n    \n    // Test setting brush color\n    QColor testColor(Qt::red);\n    item->setBrush(testColor);\n    \n    // Note: We cannot directly verify the internal color without a getter.\n    // This test assumes setBrush works; in a real test we'd need a getter.\n    // For now, we just verify the item exists and the call doesn't crash.\n    QVERIFY(item != nullptr);\n    \n    delete item;\n}\n\nvoid TestItemTransformations::testDiagramPathQuadrantCalculation()\n{\n    // Test quadrant calculation logic from DiagramPath::quad\n    // Since quad is private, we test the logic indirectly via path creation\n    DiagramItem *startItem = new DiagramItem(DiagramItem::Step, dummyMenu);\n    DiagramItem *endItem = new DiagramItem(DiagramItem::Step, dummyMenu);\n    scene->addItem(startItem);\n    scene->addItem(endItem);\n    \n    // Position items to test different quadrants\n    startItem->setPos(0, 0);\n    endItem->setPos(100, 100);  // Quadrant 2 (x2 > x1, y2 > y1)\n    \n    DiagramPath *path = new DiagramPath(startItem, endItem, \n                                         DiagramItem::TF_Right, \n                                         DiagramItem::TF_Left);\n    scene->addItem(path);\n    \n    // Verify path creation succeeded\n    QVERIFY(path->getStartItem() == startItem);\n    QVERIFY(path->getEndItem() == endItem);\n    \n    // Update path to trigger quadrant calculation\n    path->updatePath();\n    \n    // The path should be valid after update\n    QVERIFY(!path->path().isEmpty());\n    \n    delete path;\n    delete endItem;\n    delete startItem;\n}\n\nvoid TestItemTransformations::testDiagramPathUpdate()\n{\n    DiagramItem *startItem = new DiagramItem(DiagramItem::Step, dummyMenu);\n    DiagramItem *endItem = new DiagramItem(DiagramItem::Step, dummyMenu);\n    scene->addItem(startItem);\n    scene->addItem(endItem);\n    \n    startItem->setPos(0, 0);\n    endItem->setPos(200, 0);\n    \n    DiagramPath *path = new DiagramPath(startItem, endItem,\n                                         DiagramItem::TF_Right,\n                                         DiagramItem::TF_Left);\n    scene->addItem(path);\n    \n    // Store initial path\n    QPainterPath initialPath = path->path();\n    \n    // Move end item and update\n    endItem->setPos(200, 100);\n    path->updatePath();\n    \n    // Path should change after update\n    QPainterPath updatedPath = path->path();\n    QVERIFY(initialPath != updatedPath);\n    \n    delete path;\n    delete endItem;\n    delete startItem;\n}\n\nvoid TestItemTransformations::testDiagramItemGroupAddItem()\n{\n    // This is a smoke test since DiagramItemGroup implementation is incomplete\n    // We test basic creation and addItem functionality\n    DiagramItemGroup *group = new DiagramItemGroup();\n    scene->addItem(group);\n    \n    DiagramItem *item = new DiagramItem(DiagramItem::Step, dummyMenu);\n    scene->addItem(item);\n    \n    // Add item to group\n    group->addItem(item);\n    \n    // Verify item is in group's child items\n    QVERIFY(group->childItems().contains(item));\n    \n    // Verify group bounding rect is valid\n    QRectF groupBounds = group->boundingRect();\n    QVERIFY(groupBounds.width() >= 0 && groupBounds.height() >= 0);\n    \n    delete group; // Should delete child items\n}\n\nQTEST_MAIN(TestItemTransformations)\n#include \"test_item_transformations.moc\""
        },
        {
          "path": "tests/generated/test_text_operations.cpp",
          "content": "#include <QtTest>\n#include <QObject>\n#include <QString>\n#include <QTextStream>\n#include <QFile>\n#include <QDebug>\n\n// 假设的文本操作工具类（根据上下文推断）\n// 由于上下文中没有明确的纯文本操作类，我们创建一个简单的测试来验证\n// MainWindow 中与文本相关的函数（loadSavePicPath, saveSavePicPath）\n// 注意：这些函数需要 MainWindow 实例，但我们可以测试其逻辑核心\n\n// 为测试创建一个简单的文本操作包装类\nclass TextFileOperations\n{\npublic:\n    static bool saveTextToFile(const QString &filePath, const QString &content)\n    {\n        QFile file(filePath);\n        if (!file.open(QIODevice::WriteOnly | QIODevice::Text))\n            return false;\n        QTextStream out(&file);\n        out << content;\n        file.close();\n        return true;\n    }\n\n    static QString loadTextFromFile(const QString &filePath)\n    {\n        QFile file(filePath);\n        if (!file.open(QIODevice::ReadOnly | QIODevice::Text))\n            return QString();\n        QTextStream in(&file);\n        QString content = in.readAll();\n        file.close();\n        return content;\n    }\n\n    // 模拟 MainWindow::saveSavePicPath 的逻辑\n    static bool savePathToFile(const QString &filePath, const QString &pathToSave)\n    {\n        return saveTextToFile(filePath, pathToSave);\n    }\n\n    // 模拟 MainWindow::loadSavePicPath 的逻辑\n    static QString loadPathFromFile(const QString &filePath)\n    {\n        return loadTextFromFile(filePath);\n    }\n};\n\nclass TestTextOperations : public QObject\n{\n    Q_OBJECT\n\nprivate slots:\n    void initTestCase()\n    {\n        // 测试前的初始化\n    }\n\n    void cleanupTestCase()\n    {\n        // 测试后的清理\n    }\n\n    void testSaveAndLoadTextToFile()\n    {\n        QString testFilePath = \"test_save_load.txt\";\n        QString originalText = \"Test content for save/load operations\";\n\n        // 保存文本\n        bool saveResult = TextFileOperations::saveTextToFile(testFilePath, originalText);\n        QVERIFY(saveResult);\n\n        // 加载文本\n        QString loadedText = TextFileOperations::loadTextFromFile(testFilePath);\n        QCOMPARE(loadedText, originalText);\n\n        // 清理测试文件\n        QFile::remove(testFilePath);\n    }\n\n    void testLoadTextFromNonExistentFile()\n    {\n        QString nonExistentFile = \"non_existent_file_12345.txt\";\n        QString loadedText = TextFileOperations::loadTextFromFile(nonExistentFile);\n        QVERIFY(loadedText.isEmpty());\n    }\n\n    void testSavePathAndLoadPath()\n    {\n        QString pathFilePath = \"test_path_log.txt\";\n        QString originalPath = \"C:/Users/test/path/to/image.png\";\n\n        // 保存路径\n        bool saveResult = TextFileOperations::savePathToFile(pathFilePath, originalPath);\n        QVERIFY(saveResult);\n\n        // 加载路径\n        QString loadedPath = TextFileOperations::loadPathFromFile(pathFilePath);\n        QCOMPARE(loadedPath, originalPath);\n\n        // 清理测试文件\n        QFile::remove(pathFilePath);\n    }\n\n    void testEmptyPathSaveAndLoad()\n    {\n        QString emptyFilePath = \"test_empty_path.txt\";\n        QString emptyPath = \"\";\n\n        // 保存空路径\n        bool saveResult = TextFileOperations::savePathToFile(emptyFilePath, emptyPath);\n        QVERIFY(saveResult);\n\n        // 加载空路径\n        QString loadedPath = TextFileOperations::loadPathFromFile(emptyFilePath);\n        QCOMPARE(loadedPath, emptyPath);\n\n        // 清理测试文件\n        QFile::remove(emptyFilePath);\n    }\n\n    void testTextStreamOperations()\n    {\n        // 测试 QTextStream 的基本功能\n        QString testString = \"Hello, QtTest!\";\n        QBuffer buffer;\n        buffer.open(QIODevice::ReadWrite);\n        QTextStream stream(&buffer);\n        stream << testString;\n        stream.seek(0);\n        QString result;\n        stream >> result;\n        QCOMPARE(result, \"Hello,\"); // 注意：QTextStream 的 >> 操作符以空格分隔\n        buffer.close();\n    }\n};\n\nQTEST_APPLESS_MAIN(TestTextOperations)\n\n#include \"test_text_operations.moc\""
        },
        {
          "path": "tests/generated/test_path_operations.cpp",
          "content": "#include <QtTest>\n#include \"diagrampath.h\"\n#include \"diagramitem.h\"\n#include <QGraphicsScene>\n#include <QMenu>\n\nclass TestPathOperations : public QObject\n{\n    Q_OBJECT\n\nprivate slots:\n    void initTestCase();\n    void cleanupTestCase();\n    void testQuadrantCalculation_data();\n    void testQuadrantCalculation();\n    void testPathStateCalculation();\n    void testUpdatePath();\n    void testGetStartAndEndItems();\n    void testDrawHead();\n    void testDrawZig();\n\nprivate:\n    QGraphicsScene *scene;\n    QMenu *dummyMenu;\n    DiagramItem *startItem;\n    DiagramItem *endItem;\n    DiagramPath *path;\n};\n\nvoid TestPathOperations::initTestCase()\n{\n    scene = new QGraphicsScene();\n    dummyMenu = new QMenu();\n    startItem = new DiagramItem(DiagramItem::Step, dummyMenu);\n    endItem = new DiagramItem(DiagramItem::Step, dummyMenu);\n    scene->addItem(startItem);\n    scene->addItem(endItem);\n    startItem->setPos(0, 0);\n    endItem->setPos(100, 100);\n}\n\nvoid TestPathOperations::cleanupTestCase()\n{\n    delete path;\n    delete startItem;\n    delete endItem;\n    delete dummyMenu;\n    delete scene;\n}\n\nvoid TestPathOperations::testQuadrantCalculation_data()\n{\n    QTest::addColumn<QPointF>(\"startPoint\");\n    QTest::addColumn<QPointF>(\"endPoint\");\n    QTest::addColumn<int>(\"expectedQuadrant\");\n\n    QTest::newRow(\"Quadrant 1\") << QPointF(0, 0) << QPointF(100, 100) << 2;\n    QTest::newRow(\"Quadrant 2\") << QPointF(100, 0) << QPointF(0, 100) << 1;\n    QTest::newRow(\"Quadrant 3\") << QPointF(100, 100) << QPointF(0, 0) << 4;\n    QTest::newRow(\"Quadrant 4\") << QPointF(0, 100) << QPointF(100, 0) << 3;\n    QTest::newRow(\"Same point\") << QPointF(50, 50) << QPointF(50, 50) << 0;\n}\n\nvoid TestPathOperations::testQuadrantCalculation()\n{\n    QFETCH(QPointF, startPoint);\n    QFETCH(QPointF, endPoint);\n    QFETCH(int, expectedQuadrant);\n\n    int result = DiagramPath::quad(startPoint, endPoint);\n    QCOMPARE(result, expectedQuadrant);\n}\n\nvoid TestPathOperations::testPathStateCalculation()\n{\n    startItem->setPos(0, 0);\n    endItem->setPos(200, 200);\n    DiagramItem::TransformState startState = DiagramItem::TF_Right;\n    DiagramItem::TransformState endState = DiagramItem::TF_Left;\n    path = new DiagramPath(startItem, endItem, startState, endState);\n    scene->addItem(path);\n    path->updatePath();\n\n    int expectedState = startState * 100 + endState * 10 + 4;\n    QCOMPARE(path->m_state, expectedState);\n}\n\nvoid TestPathOperations::testUpdatePath()\n{\n    startItem->setPos(50, 50);\n    endItem->setPos(150, 150);\n    DiagramItem::TransformState startState = DiagramItem::TF_Bottom;\n    DiagramItem::TransformState endState = DiagramItem::TF_Top;\n    path = new DiagramPath(startItem, endItem, startState, endState);\n    scene->addItem(path);\n    path->updatePath();\n\n    QVERIFY(!path->path().isEmpty());\n    QVERIFY(path->path().elementCount() > 0);\n}\n\nvoid TestPathOperations::testGetStartAndEndItems()\n{\n    DiagramItem::TransformState startState = DiagramItem::TF_Top;\n    DiagramItem::TransformState endState = DiagramItem::TF_Bottom;\n    path = new DiagramPath(startItem, endItem, startState, endState);\n    scene->addItem(path);\n\n    QCOMPARE(path->getStartItem(), startItem);\n    QCOMPARE(path->getEndItem(), endItem);\n}\n\nvoid TestPathOperations::testDrawHead()\n{\n    QPointF endpoint(100, 100);\n    QPointF endRectPoint(90, 100);\n    QPainterPath testPath;\n    testPath.moveTo(endpoint);\n    testPath.lineTo(endRectPoint);\n    DiagramPath::drawHead(endpoint, endRectPoint);\n    QVERIFY(true);\n}\n\nvoid TestPathOperations::testDrawZig()\n{\n    QPointF startPoint(0, 0);\n    QPointF endPoint(100, 100);\n    QPainterPath testPath;\n    testPath.moveTo(startPoint);\n    DiagramPath::drawZig(startPoint, endPoint);\n    QVERIFY(true);\n}\n\nQTEST_MAIN(TestPathOperations)\n#include \"test_path_operations.moc\"\n"
        },
        {
          "path": "tests/generated/test_scene_cleanup.cpp",
          "content": "#include <QtTest>\n#include <QGraphicsScene>\n#include <QGraphicsItem>\n#include <QGraphicsRectItem>\n#include <QGraphicsEllipseItem>\n#include <QList>\n#include <QDebug>\n\nclass TestSceneCleanup : public QObject\n{\n    Q_OBJECT\n\nprivate slots:\n    void testSceneClearRemovesAllItems();\n    void testSceneDestructionCleansUpMemory();\n    void testAddRemoveItemsUpdatesSceneRect();\n    void testSceneClearSignals();\n};\n\nvoid TestSceneCleanup::testSceneClearRemovesAllItems()\n{\n    QGraphicsScene scene;\n    \n    // Add some dummy items\n    QGraphicsRectItem *rectItem = new QGraphicsRectItem(0, 0, 100, 100);\n    QGraphicsEllipseItem *ellipseItem = new QGraphicsEllipseItem(0, 0, 50, 50);\n    \n    scene.addItem(rectItem);\n    scene.addItem(ellipseItem);\n    \n    QCOMPARE(scene.items().size(), 2);\n    \n    // Clear the scene\n    scene.clear();\n    \n    // After clear, scene should have no items\n    QCOMPARE(scene.items().size(), 0);\n    \n    // Items should be deleted (owned by scene)\n    // Note: We can't directly test deletion, but items() should be empty\n}\n\nvoid TestSceneCleanup::testSceneDestructionCleansUpMemory()\n{\n    // This test verifies that when scene is destroyed, all items are cleaned up\n    // We'll use a scoped pointer to verify destruction\n    QGraphicsScene *scene = new QGraphicsScene();\n    \n    // Add items that are owned by the scene\n    QGraphicsRectItem *rectItem = new QGraphicsRectItem(0, 0, 100, 100);\n    QGraphicsEllipseItem *ellipseItem = new QGraphicsEllipseItem(0, 0, 50, 50);\n    \n    scene->addItem(rectItem);\n    scene->addItem(ellipseItem);\n    \n    // Delete the scene - should automatically delete all items\n    delete scene;\n    \n    // If we get here without crashes, the test passes\n    QVERIFY(true);\n}\n\nvoid TestSceneCleanup::testAddRemoveItemsUpdatesSceneRect()\n{\n    QGraphicsScene scene;\n    \n    // Initial scene rect should be empty or default\n    QVERIFY(scene.sceneRect().isNull() || scene.sceneRect().isEmpty());\n    \n    // Add an item\n    QGraphicsRectItem *item = new QGraphicsRectItem(-50, -50, 100, 100);\n    scene.addItem(item);\n    \n    // Scene rect should now include the item\n    QVERIFY(scene.sceneRect().contains(item->boundingRect()));\n    \n    // Remove the item\n    scene.removeItem(item);\n    delete item; // Since we created it with new\n    \n    // Scene rect might still be the same or recalculated\n    // This is implementation dependent, so we just verify no crash\n    QVERIFY(true);\n}\n\nvoid TestSceneCleanup::testSceneClearSignals()\n{\n    QGraphicsScene scene;\n    \n    // Add some items\n    QGraphicsRectItem *rectItem = new QGraphicsRectItem(0, 0, 100, 100);\n    scene.addItem(rectItem);\n    \n    // We could test for changed() signal emission, but for simplicity\n    // we just verify the clear operation completes\n    scene.clear();\n    \n    QCOMPARE(scene.items().size(), 0);\n}\n\nQTEST_MAIN(TestSceneCleanup)\n#include \"test_scene_cleanup.moc\""
        },
        {
          "path": "tests/generated/test_performance.cpp",
          "content": "#include <QtTest>\n#include <QCoreApplication>\n#include <QElapsedTimer>\n#include <QDebug>\n\n// 假设的性能测试类\nclass TestPerformance : public QObject\n{\n    Q_OBJECT\n\nprivate slots:\n    void initTestCase();\n    void cleanupTestCase();\n    void test_diagramItem_creation_performance();\n    void test_diagramPath_quad_calculation_performance();\n    void test_diagramItemGroup_boundingRect_performance();\n    void test_arrow_updatePosition_performance();\n    void test_diagramTextItem_focus_performance();\n    void test_diagramScene_mousePress_performance();\n    void test_findReplaceDialog_creation_performance();\n    void test_deleteCommand_undo_redo_performance();\n    void test_mainwindow_savePicPath_performance();\n    void test_diagramItem_paint_performance();\n};\n\nvoid TestPerformance::initTestCase()\n{\n    // 初始化资源（如果需要）\n}\n\nvoid TestPerformance::cleanupTestCase()\n{\n    // 清理资源（如果需要）\n}\n\nvoid TestPerformance::test_diagramItem_creation_performance()\n{\n    QElapsedTimer timer;\n    timer.start();\n    for (int i = 0; i < 1000; ++i) {\n        // 模拟 DiagramItem 创建（由于缺少完整上下文，这里使用占位）\n        // 实际测试中应包含：DiagramItem *item = new DiagramItem(DiagramItem::Step, nullptr);\n        // 然后 delete item;\n        QGraphicsItem *dummy = new QGraphicsRectItem(0, 0, 100, 100);\n        delete dummy;\n    }\n    qint64 elapsed = timer.elapsed();\n    qDebug() << \"DiagramItem creation (1000 iterations) took\" << elapsed << \"ms\";\n    QVERIFY(elapsed < 5000); // 宽松的性能阈值（5秒）\n}\n\nvoid TestPerformance::test_diagramPath_quad_calculation_performance()\n{\n    QElapsedTimer timer;\n    timer.start();\n    for (int i = 0; i < 100000; ++i) {\n        // 模拟 quad 函数计算（基于 diagrampath.cpp 中的逻辑）\n        QPointF startPoint(i % 1000, i % 500);\n        QPointF endPoint((i + 300) % 1000, (i + 200) % 500);\n        int quadResult = 0;\n        if (startPoint.x() >= endPoint.x() && startPoint.y() >= endPoint.y()) {\n            quadResult = 4;\n        } else if (startPoint.x() <= endPoint.x() && startPoint.y() >= endPoint.y()) {\n            quadResult = 1;\n        } else if (startPoint.x() >= endPoint.x() && startPoint.y() <= endPoint.y()) {\n            quadResult = 3;\n        } else if (startPoint.x() <= endPoint.x() && startPoint.y() <= endPoint.y()) {\n            quadResult = 2;\n        }\n        Q_UNUSED(quadResult);\n    }\n    qint64 elapsed = timer.elapsed();\n    qDebug() << \"DiagramPath quad calculation (100k iterations) took\" << elapsed << \"ms\";\n    QVERIFY(elapsed < 100); // 应非常快\n}\n\nvoid TestPerformance::test_diagramItemGroup_boundingRect_performance()\n{\n    QElapsedTimer timer;\n    timer.start();\n    for (int i = 0; i < 10000; ++i) {\n        // 模拟 boundingRect 计算（基于 diagramitemgroup.cpp）\n        QSizeF m_grapSize(200 + i % 50, 150 + i % 30);\n        QRectF rect(0, 0, m_grapSize.width(), m_grapSize.height());\n        Q_UNUSED(rect);\n    }\n    qint64 elapsed = timer.elapsed();\n    qDebug() << \"DiagramItemGroup boundingRect (10k iterations) took\" << elapsed << \"ms\";\n    QVERIFY(elapsed < 50);\n}\n\nvoid TestPerformance::test_arrow_updatePosition_performance()\n{\n    QElapsedTimer timer;\n    timer.start();\n    for (int i = 0; i < 5000; ++i) {\n        // 模拟 updatePosition 中的线计算（基于 arrow.cpp）\n        QPointF start(i % 800, i % 600);\n        QPointF end((i + 400) % 800, (i + 300) % 600);\n        QLineF line(start, end);\n        Q_UNUSED(line);\n    }\n    qint64 elapsed = timer.elapsed();\n    qDebug() << \"Arrow updatePosition simulation (5k iterations) took\" << elapsed << \"ms\";\n    QVERIFY(elapsed < 30);\n}\n\nvoid TestPerformance::test_diagramTextItem_focus_performance()\n{\n    QElapsedTimer timer;\n    timer.start();\n    for (int i = 0; i < 1000; ++i) {\n        // 模拟焦点事件开销（创建和销毁 QGraphicsTextItem）\n        QGraphicsTextItem *textItem = new QGraphicsTextItem();\n        textItem->setTextInteractionFlags(Qt::TextEditorInteraction);\n        textItem->setPlainText(\"Test performance text\");\n        delete textItem;\n    }\n    qint64 elapsed = timer.elapsed();\n    qDebug() << \"DiagramTextItem focus simulation (1k iterations) took\" << elapsed << \"ms\";\n    QVERIFY(elapsed < 1000);\n}\n\nvoid TestPerformance::test_diagramScene_mousePress_performance()\n{\n    QElapsedTimer timer;\n    timer.start();\n    for (int i = 0; i < 1000; ++i) {\n        // 模拟鼠标事件处理中的模式检查（基于 diagramscene.cpp 片段）\n        DiagramScene::Mode myMode = DiagramScene::MoveItem;\n        bool isInsertPath = (i % 2 == 0);\n        if (isInsertPath) {\n            myMode = DiagramScene::InsertPath;\n        }\n        Q_UNUSED(myMode);\n    }\n    qint64 elapsed = timer.elapsed();\n    qDebug() << \"DiagramScene mousePress mode check (1k iterations) took\" << elapsed << \"ms\";\n    QVERIFY(elapsed < 10);\n}\n\nvoid TestPerformance::test_findReplaceDialog_creation_performance()\n{\n    QElapsedTimer timer;\n    timer.start();\n    for (int i = 0; i < 100; ++i) {\n        // 模拟 FindReplaceDialog 创建（基于 findreplacedialog.cpp）\n        // 实际测试中应包含：FindReplaceDialog dialog;\n        // 这里使用 QDialog 作为占位\n        QDialog dialog;\n        QLineEdit *findLineEdit = new QLineEdit(&dialog);\n        QPushButton *findButton = new QPushButton(\"Find\", &dialog);\n        Q_UNUSED(findLineEdit);\n        Q_UNUSED(findButton);\n    }\n    qint64 elapsed = timer.elapsed();\n    qDebug() << \"FindReplaceDialog creation simulation (100 iterations) took\" << elapsed << \"ms\";\n    QVERIFY(elapsed < 500);\n}\n\nvoid TestPerformance::test_deleteCommand_undo_redo_performance()\n{\n    QElapsedTimer timer;\n    timer.start();\n    for (int i = 0; i < 5000; ++i) {\n        // 模拟简单的命令开销（基于 deletecommand.cpp 中的结构）\n        QPointF m_itemPos(i % 100, i % 100);\n        QSizeF m_itemSize(50 + i % 20, 30 + i % 20);\n        Q_UNUSED(m_itemPos);\n        Q_UNUSED(m_itemSize);\n    }\n    qint64 elapsed = timer.elapsed();\n    qDebug() << \"DeleteCommand state simulation (5k iterations) took\" << elapsed << \"ms\";\n    QVERIFY(elapsed < 20);\n}\n\nvoid TestPerformance::test_mainwindow_savePicPath_performance()\n{\n    QElapsedTimer timer;\n    timer.start();\n    for (int i = 0; i < 1000; ++i) {\n        // 模拟文件写入开销（基于 mainwindow.cpp 中的 saveSavePicPath）\n        QString filePath = QCoreApplication::applicationDirPath() + \"/test_perf_log.txt\";\n        QFile file(filePath);\n        if (file.open(QIODevice::WriteOnly | QIODevice::Text)) {\n            QTextStream out(&file);\n            out << \"Test performance iteration \" << i;\n            file.close();\n        }\n        file.remove(); // 清理\n    }\n    qint64 elapsed = timer.elapsed();\n    qDebug() << \"MainWindow savePicPath simulation (1k iterations) took\" << elapsed << \"ms\";\n    QVERIFY(elapsed < 2000); // 文件 I/O 较慢，阈值放宽\n}\n\nvoid TestPerformance::test_diagramItem_paint_performance()\n{\n    QElapsedTimer timer;\n    timer.start();\n    for (int i = 0; i < 100; ++i) {\n        // 模拟绘图路径计算（基于 diagramitem.cpp 中的 StartEnd 情况）\n        qreal w = 150 + i % 20;\n        qreal h = 100 + i % 20;\n        qreal b = 5;\n        QPainterPath path;\n        path.moveTo(b + (w - 2 * b) * 0.15, b);\n        path.arcTo(QRectF(b, b, (w - 2 * b) * 0.3, h - 2 * b), 90, 180);\n        path.lineTo(w - b - (w - 2 * b) * 0.15, h - b);\n        path.arcTo(QRectF(w - b - (w - 2 * b) * 0.3, b, (w - 2 * b) * 0.3, h - 2 * b), 270, 180);\n        path.closeSubpath();\n        Q_UNUSED(path);\n    }\n    qint64 elapsed = timer.elapsed();\n    qDebug() << \"DiagramItem paint path simulation (100 iterations) took\" << elapsed << \"ms\";\n    QVERIFY(elapsed < 10);\n}\n\nQTEST_MAIN(TestPerformance)\n\n#include \"test_performance.moc\""
        }
      ],
      "stats": {
        "files_generated": 24,
        "cases_approx": 162
      }
    },
    "applied": [
      "tests/generated/tests.pro (0 cases)",
      "test_diagramitem.cpp (6 cases)",
      "test_deletecommand.cpp (2 cases)",
      "test_diagrampath.cpp (4 cases)",
      "test_findreplacedialog.cpp (5 cases)",
      "tests/generated/test_diagramitemgroup.cpp (7 cases)",
      "tests/generated/test_diagrampath.cpp (5 cases)",
      "tests/generated/test_diagramscene.cpp (28 cases)",
      "tests/generated/test_diagramtextitem.cpp (12 cases)",
      "tests/generated/test_arrow.cpp (6 cases)",
      "tests/generated/test_deletecommand.cpp (5 cases)",
      "tests/generated/test_findreplacedialog.cpp (9 cases)",
      "tests/generated/test_mainwindow.cpp (6 cases)",
      "tests/generated/test_geometry_utils.cpp (5 cases)",
      "tests/generated/test_item_selection.cpp (7 cases)",
      "tests/generated/test_z_order.cpp (4 cases)",
      "tests/generated/test_scene_serialization.cpp (10 cases)",
      "tests/generated/test_command_pattern.cpp (4 cases)",
      "tests/generated/test_bounding_boxes.cpp (5 cases)",
      "tests/generated/test_item_transformations.cpp (6 cases)",
      "tests/generated/test_text_operations.cpp (5 cases)",
      "tests/generated/test_path_operations.cpp (7 cases)",
      "tests/generated/test_scene_cleanup.cpp (4 cases)",
      "tests/generated/test_performance.cpp (10 cases)"
    ],
    "total_cases_count": 162
  },
  "findings": [
    {
      "category": "testgen",
      "severity": "warning",
      "title": "生成文件失败: tests/generated/test_diagramitem.cpp",
      "details": "Failed to obtain valid JSON after 3 attempts: JSON parse failed: Expecting value: line 1 column 1 (char 0). Extracted string: ''\nLast response preview: {\n    \"schema\": \"qt_test_cpp\",\n    \"files\": [\n        {\n            \"name\": \"tests/generated/test_diagramitem.cpp\",\n            \"content\": \"#include <QtTest>\\n#include <QMenu>\\n#include <QGraphicsScene>\\n#include <QPainter>\\n#include <QStyleOptionGraphicsItem>\\n#include <QWidget>\\n#include \\\"../diagramitem.h\\\"\\n#include \\\"../diagramtextitem.h\\\"\\n\\nclass TestDiagramItem : public QObject\\n{\\n    Q_OBJECT\\n\\nprivate slots:\\n    void initTestCase();\\n    void cleanupTestCase();\\n    void testConstructor();\\n    void testDiagramType();\\n    void testBoundingRect();\\n    void testSetBrush();\\n    void testSetFixedSize();\\n    void testRotationAngle();\\n    void testTextItemAssociation();\\n    void testPaint();\\n    void testFlags();\\n    void testHoverEvents();\\n    void testContextMenu();\\n    void testLinkWhere();\\n    void testRectWhere();\\n    void testGetSize();\\n    void testSetSize();\\n    void testPolygon();\\n    void testTransformStateEnum();\\n\\nprivate:\\n    QMenu *testMenu;\\n    DiagramItem *itemStep;\\n    DiagramItem *itemConditional;\\n    DiagramItem *itemStartEnd;\\n    DiagramItem *itemCircular;\\n    DiagramItem *itemDocument;\\n    DiagramItem *itemPredefinedProcess;\\n    DiagramItem *itemStoredData;\\n};\\n\\nvoid TestDiagramItem::initTestCase()\\n{\\n    testMenu = new QMenu();\\n    itemStep = new DiagramItem(DiagramItem::Step, testMenu);\\n    itemConditional = new DiagramItem(DiagramItem::Conditional, testMenu);\\n    itemStartEnd = new DiagramItem(DiagramItem::StartEnd, testMenu);\\n    itemCircular = new DiagramItem(DiagramItem::circular, testMenu);\\n    itemDocument = new DiagramItem(DiagramItem::Document, testMenu);\\n    itemPredefinedProcess = new DiagramItem(DiagramItem::PredefinedProcess, testMenu);\\n    itemStoredData = new DiagramItem(DiagramItem::StoredData, testMenu);\\n}\\n\\nvoid TestDiagramItem::cleanupTestCase()\\n{\\n    delete itemStep;\\n    delete itemConditional;\\n    delete itemStartEnd;\\n    delete itemCircular;\\n    delete itemDocument;\\n    del",
      "file": null,
      "line": null,
      "rule_id": null,
      "evidence": {}
    },
    {
      "category": "testgen",
      "severity": "info",
      "title": "已生成 QtTest：24 个文件，共约 162 个用例",
      "details": "生成文件明细：\ntests/generated/tests.pro (0 cases)\ntest_diagramitem.cpp (6 cases)\ntest_deletecommand.cpp (2 cases)\ntest_diagrampath.cpp (4 cases)\ntest_findreplacedialog.cpp (5 cases)\ntests/generated/test_diagramitemgroup.cpp (7 cases)\ntests/generated/test_diagrampath.cpp (5 cases)\ntests/generated/test_diagramscene.cpp (28 cases)\ntests/generated/test_diagramtextitem.cpp (12 cases)\ntests/generated/test_arrow.cpp (6 cases)\ntests/generated/test_deletecommand.cpp (5 cases)\ntests/generated/test_findreplacedialog.cpp (9 cases)\ntests/generated/test_mainwindow.cpp (6 cases)\ntests/generated/test_geometry_utils.cpp (5 cases)\ntests/generated/test_item_selection.cpp (7 cases)\ntests/generated/test_z_order.cpp (4 cases)\ntests/generated/test_scene_serialization.cpp (10 cases)\ntests/generated/test_command_pattern.cpp (4 cases)\ntests/generated/test_bounding_boxes.cpp (5 cases)\ntests/generated/test_item_transformations.cpp (6 cases)\ntests/generated/test_text_operations.cpp (5 cases)\ntests/generated/test_path_operations.cpp (7 cases)\ntests/generated/test_scene_cleanup.cpp (4 cases)\ntests/generated/test_performance.cpp (10 cases)",
      "file": null,
      "line": null,
      "rule_id": null,
      "evidence": {}
    }
  ]
}